<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="baidu-site-verification" content="ATveXKozGc" />
<meta name="google-site-verification" content="9Dtaw-SE4V3dRsy6DfbFYR9RQFubScbTof4pPtKEJkE" />
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>技术笔记集合 | yuweiguo&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="状态：未完成">
<meta property="og:type" content="article">
<meta property="og:title" content="技术笔记集合">
<meta property="og:url" content="http://yoursite.com/2016/03/23/note/index.html">
<meta property="og:site_name" content="yuweiguo's blog">
<meta property="og:description" content="状态：未完成">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/98641-733b821197251592.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/98641-5f72fbc6d7a47cea.png?imageMogr2/auto-orient/strip%7CimageView2/2">
<meta property="og:updated_time" content="2016-04-09T01:19:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="技术笔记集合">
<meta name="twitter:description" content="状态：未完成">
  
    <link rel="alternative" href="/atom.xml" title="yuweiguo&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="assets/img/yuweiguo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">于卫国</a></h1>
		</hgroup>

		
		<p class="header-subtitle">和喜欢的一切在一起。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yuweiguocn" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/weiguo58" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:yuweiguocn@gmail.com" title="mail">mail</a>
					        
								<a class="dashang" target="_blank" href="http://yuweiguocn.github.io/2015/06/19/dashang/" title="dashang">dashang</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/aidl/" style="font-size: 10px;">aidl</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/android-studio/" style="font-size: 14.44px;">android studio</a> <a href="/tags/android-ux/" style="font-size: 10px;">android ux</a> <a href="/tags/asynctask/" style="font-size: 10px;">asynctask</a> <a href="/tags/basic/" style="font-size: 17.78px;">basic</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/broadcast/" style="font-size: 10px;">broadcast</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/data-binding/" style="font-size: 13.33px;">data binding</a> <a href="/tags/demo/" style="font-size: 14.44px;">demo</a> <a href="/tags/design/" style="font-size: 10px;">design</a> <a href="/tags/doc/" style="font-size: 16.67px;">doc</a> <a href="/tags/error/" style="font-size: 10px;">error</a> <a href="/tags/guide/" style="font-size: 12.22px;">guide</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/intentservice/" style="font-size: 10px;">intentservice</a> <a href="/tags/interview/" style="font-size: 14.44px;">interview</a> <a href="/tags/java/" style="font-size: 12.22px;">java</a> <a href="/tags/lint/" style="font-size: 10px;">lint</a> <a href="/tags/mac/" style="font-size: 11.11px;">mac</a> <a href="/tags/note/" style="font-size: 10px;">note</a> <a href="/tags/notification/" style="font-size: 10px;">notification</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/peformance/" style="font-size: 10px;">peformance</a> <a href="/tags/perfermance/" style="font-size: 10px;">perfermance</a> <a href="/tags/program/" style="font-size: 10px;">program</a> <a href="/tags/series/" style="font-size: 14.44px;">series</a> <a href="/tags/service/" style="font-size: 12.22px;">service</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/solution/" style="font-size: 10px;">solution</a> <a href="/tags/source/" style="font-size: 10px;">source</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/support/" style="font-size: 18.89px;">support</a> <a href="/tags/teach/" style="font-size: 10px;">teach</a> <a href="/tags/tips/" style="font-size: 15.56px;">tips</a> <a href="/tags/toolbar/" style="font-size: 10px;">toolbar</a> <a href="/tags/translate/" style="font-size: 17.78px;">translate</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://litten.github.io/">Litten</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com">Github</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/growth58">CSDN</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">于卫国</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="assets/img/yuweiguo.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">于卫国</h1>
			</hgroup>
			
			<p class="header-subtitle">和喜欢的一切在一起。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yuweiguocn" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/weiguo58" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:yuweiguocn@gmail.com" title="mail">mail</a>
			        
						<a class="dashang" target="_blank" href="http://yuweiguocn.github.io/2015/06/19/dashang/" title="dashang">dashang</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-note" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/23/note/" class="article-date">
  	<time datetime="2016-03-23T13:23:33.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      技术笔记集合
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/note/">note</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>状态：未完成</p>
<a id="more"></a>
<p>原文链接：<a href="http://www.jianshu.com/p/f4a7d8369caa" target="_blank" rel="external">http://www.jianshu.com/p/f4a7d8369caa</a></p>
<p>Material配色方案</p>
<p><a href="http://www.materialpalette.com/lime/lime" target="_blank" rel="external">materialpalette</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/98641-733b821197251592.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/jpg" alt=""></p>
<p>这个网站非常简单，一键生成XML资源文件，为了各位懒人，我直接把style贴出来了，网站内下载导入即可用<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="property">name</span>=<span class="string">"AppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><br><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"colorPrimary"</span>&gt;@color/primary&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;@color/primary_dark&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"colorAccent"</span>&gt;@color/accent&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:textColor"</span>&gt;@color/primary_text&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:textColorSecondary"</span>&gt;@color/secondary_text&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:icon"</span>&gt;@color/icons&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:divider"</span>&gt;@color/divider&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用Mac自带的吸管工具</p>
<p><img src="http://upload-images.jianshu.io/upload_images/98641-5f72fbc6d7a47cea.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""><br>这个工具可以参考其他App的配色，注意要记得配置View-&gt;Display Values-&gt;as Hex</p>
<p>0201   //DVD2  day01</p>
<p>移动通信技术:</p>
<pre><code>1G    模拟制式    只能进行语音通话.

2G    GSM, CDMA    发送短信接收数据.

2.5G    GPRS, EDGE    数据收发的速度.

3G    WCDMA, CDMA2000, TD-SCDMA    查看高清图片, 看微博, 看小电影.

3.5G    HSDPA, HSDPA+    比3G速度上提升了.

4G    TD-LTE        下载速度 100Mb/s = 12MB/s 上传速度 10Mb/s = 1MB/s
</code></pre><p>100Mb/s</p>
<p>bit  位</p>
<p>Byte    8位</p>
<p>小米MUI, Ophone, 阿里云os, 锤子.</p>
<p>虚拟机的区别:</p>
<p>JVM:<br>.java -&gt; javac -&gt; .class -&gt; jar -&gt; .jar<br>架构: 堆和栈的架构.</p>
<p>DVM:<br>.java -&gt; javac -&gt; .class -&gt; dx.bat -&gt; .dex<br>架构: 寄存器(cpu上的一块高速缓存)</p>
<p>在hosts文件中追加:<br>74.125.113.121 developer.android.com</p>
<p>203.208.46.146 dl.google.com</p>
<p>203.208.46.146 dl-ssl.google.com</p>
<p>adb android debug brige 调试桥, 用于模拟器和eclipse连接的工具</p>
<p>中文翻译文档: 农民伯伯</p>
<p>修改虚拟机<br>在path中追加adb.exe的父路径<br>D:\IDE\adt-bundle-windows-x86_64_20140101\sdk\platform-tools</p>
<p>linux系统中#号代表超级用户, $代表普通用户.</p>
<p>工程目录结构:<br>src: 存放java代码</p>
<p>gen: 自动生成文件目录. R文件(资源的地址值).</p>
<p>project.properties: 存放当前工程采用工具包的版本号</p>
<p>libs: 当前工程依赖的jar包.</p>
<p>assets: 资产目录. 放置一些程序需要的图片, 媒体文件.</p>
<p>bin: 工程编译目录.</p>
<p>res: 资源目录resources<br>    drawable: 放置程序用到的图片.<br>    layout: 布局.<br>    menu: 存放程序的菜单布局.<br>    values: 存放程序所需要的一些资源(字符串, 样式, 主体, 尺寸等);<br>        values-sw600dp: 存放7寸平板尺寸的单位.<br>        values-sw720dp-land: 存放10寸平板尺寸的单位.<br>        values-v11: 存放api 11 android3.0的主题.<br>        values-v14: 存放api 14 android4.0的主题.</p>
<p>AndroidManifest.xml: 程序的入口文件.配置了一些版本信息和android下的组件.<br>    第一个显示的界面activity为: 包含<br>                    <intent-filter><br>                                    <action android:name="android.intent.action.MAIN"></action></intent-filter></p>
<pre><code>    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre><p>proguard-project.txt: 混淆工程, 让别人拿到项目之后看不懂.</p>
<p>显示文本内容的控件: TextView 文本<br>让用户输入的文本框: EditText 输入框<br>按钮: Button    按钮</p>
<p>0202</p>
<p>TableRow 表示单元行, 宽度小于填充父元素, 不起作用.</p>
<p>注意指定在TableLayout属性中. 取值可以用,号分隔<br>android:shrinkColumns        收缩列<br>android:stretchColumns        拉伸列<br>android:collapseColumns        隐藏列</p>
<p>android:layout_column        指定列(作用在列的身上)<br>android:layout_span        合并列(作用在列的身上)</p>
<p>应用场景:<br>    绝大部分的布局都采用:<br>        LinearLayout    线性布局<br>        RelativeLayout    相对布局</p>
<pre><code>采用在可以指定具体坐标的布局中(植物大战僵尸):
    AbsoluteLayout    绝对布局

注册页面:
    TableLayout        表格布局

电影播放器:
    FrameLayout        帧布局
</code></pre><p>常用的单位: 宽高: dp/dip  字体大小: sp</p>
<p>压力测试, 冒烟测试: monkey<br>测试整个系统:  adb shell monkey -v 事件的数量<br>测试某个程序: adb shell monkey -p 包名 -v 事件的数量</p>
<p>android下使用Junit测试:<br>在清单文件中配置:<br>manifest节点下, 指定测试的信息和测试的包<br>    <instrumentation android:name="android.test.InstrumentationTestRunner" android:targetpackage="com.itheima29.junitdemo"><br>    </instrumentation></p>
<p>application节点下, 指定测试所用的包:<br>    <uses-library android:name="android.test.runner"></uses-library></p>
<p>存储用户信息:<br>/data/data/com.itheima29.qqlogin</p>
<p>存储的是应用程序运行的配置数据.<br>getFilesDir();    /data/data/包名/files<br>/data/data/com.itheima29.qqlogin/files/</p>
<p>存储的是不可以影响到运行的文件.<br>getCacheDir();    /data/data/包名/cache<br>/data/data/com.itheima29.qqlogin/cache</p>
<p>sd卡的路径:<br>/mnt/sdcard/</p>
<p>动态获取sd卡的路径: File sdcardFile = Environment.getExternalStorageDirectory();</p>
<p>5037端口adb连接桥的端口.</p>
<p>/data/data/com.itheima29.permission/files</p>
<p>修改权限命令: chmod 666 文件名</p>
<p>SharedPreferences存储数据: /data/data/包名/shared_prefs</p>
<ol>
<li>获得SharedPreferences对象.</li>
<li>获得编辑器对象Editor</li>
<li>使用编辑器对象put数据.</li>
<li>提交到本地editor.commit();</li>
</ol>
<p>SharedPreferences读取数据:</p>
<ol>
<li>获得SharedPreferences对象.</li>
<li>SharedPreferences.get() 得到数据.</li>
</ol>
<p>0204</p>
<ol>
<li>加载驱动.</li>
<li>打开连接.</li>
<li>操作数据库.</li>
</ol>
<p>create table person(<br>       id integer primary key autoincrement,<br>       name varchar(20),<br>       age integer<br>);</p>
<p>insert into person(name, age) values(‘lisi’, 18);</p>
<p>delete from person where name = ‘lisi’);</p>
<p>update person set name = ‘zhangsan’ where name = ‘lisi’;</p>
<p>select * from person where id = 1;</p>
<p>select * from person;</p>
<p>SQlite数据库:<br>存放的位置: /data/data/包名/databases/itheima29.db</p>
<p>创建表:<br>在onCreate方法中创建表, 因为数据库创建时, 跟着数据库创建就初始化一些表.</p>
<p>DAO(database access object)</p>
<p>游标结果集Cursor, 默认查询出来是在-1的位置上.</p>
<p>数据库的事物:<br>db.beginTransaction();    // 开启事物<br>db.setTransactionSuccessful();        // 设置回滚点, 提交. 如果没有设置这个方法, 不会真正操作数据库<br>db.endTransaction();        // 结束事物</p>
<p>展示列表:<br>LinearLayout + ScrollView 方式: 数据量大的时候, 内存溢出.</p>
<p>ListView: 数据列表.<br>    MVC: mode 数据模型List<person>, view 视图ListView, controller 控制器. Adapter 数据适配器</person></p>
<p>LayoutInflater 布局填充器(打气筒), 可以把一个xml布局文件转换成一个View对象.</p>
<p>ContentResolver 内容提供者访问对象</p>
<p>访问系统短信的uri : content://sms</p>
<p>收件箱的uri: content://sms/inbox<br>    (操作的表和上面的Content://sms操作的一张表,<br>    不同的地方是content://sms/inbox会帮我们设置type)</p>
<p>0205</p>
<ol>
<li>raw_contacts 表 存放这有多少个联系人.</li>
<li>data 表中的raw_contact_id 和 raw_contacts表中的_id是对应的.</li>
<li>data 表中存放着联系人的所有的数据, 对应的联系人的id是raw_contacts表中的_id的联系人.</li>
<li>data 表的data1列的值的类型, 对应的是mimetypes表中的类型. 5 号码, 6 姓名, 1 邮箱.</li>
</ol>
<p>查询所有联系人:</p>
<ol>
<li>查询raw_contacts表的_id, 查出所有联系人的id.</li>
<li>查询联系人对应的数据, 根据raw_contacts表的_id去data表中查询raw_contact_id和_id相等的数据.</li>
<li>数据都是存储在data1这一列, 要区分号码或者姓名需要根据mimetype_id来区分: 5 号码, 6 姓名, 1 邮箱.</li>
</ol>
<p>raw_contacts表的uri: content://com.android.contacts/raw_contacts<br>data表的uri: content://com.android.contacts/data</p>
<p>添加联系人:</p>
<ol>
<li>raw_contacts表中添加一条数据, 得到最新的id</li>
<li>使用最新的id在data表中添加三条数据.</li>
</ol>
<p>内容观察者:</p>
<ol>
<li><p>在内容提供者中通知内容改变.<br> getContext().getContentResolver().notifyChange(NOTIFY_URI, null);</p>
</li>
<li><p>监听发出的通知<br> getContentResolver().registerContentObserver(uri, true, new ContentObserver(new Handler()) {</p>
<pre><code>    @Override
    public void onChange(boolean selfChange) {
        System.out.println(&quot;收到改变的消息了.&quot;);
    }
});
</code></pre></li>
<li><p>执行修改.</p>
</li>
</ol>
<p>ANR 异常 application not response 应用程序无响应</p>
<p>// 在错误的线程调用异常.<br>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</p>
<p>谁创建的对象谁才能改变他.</p>
<p>只有主线程(UI线程)才能修改界面, 子线程不可以.</p>
<p>Handler 消息处理器.</p>
<p>4.0以后不允许网络工作在主线程中调用. 4.0以前没问题.<br>android.os.NetworkOnMainThreadException<br>    网络工作在主线程执行的异常.</p>
<p>android系统下的默认编码: utf-8</p>
<p>10.0.2.2 这个地址内置在android系统中, 是模拟器访问计算机的地址.</p>
<p><a href="http://localhost:8080/ServerItheima29/servlet/LoginServlet?username=%E5%BC%A0%E4%B8%89&amp;password=321" target="_blank" rel="external">http://localhost:8080/ServerItheima29/servlet/LoginServlet?username=%E5%BC%A0%E4%B8%89&amp;password=321</a></p>
<p><a href="https://github.com" target="_blank" rel="external">https://github.com</a></p>
<p>0207</p>
<ol>
<li><p>获得远程文件的大小.</p>
</li>
<li><p>在本地创建一个跟远程文件大小一样的文件.</p>
</li>
<li><p>开启多线程下载.<br> 1). 计算每个线程需要下载的大小.</p>
<pre><code>根据文件的总长度除以线程是数量得到每一块的大小
    10 / 3 = 3; 每一块的大小
线程0: 0~2    0 = 0 * 3;     2 = ((0 + 1) * 3) -1;

线程1: 3~5    3 = 1 * 3;     5 = ((1 + 1) * 3)) -1;

线程2: 6~9    6 = 2 * 3;    9 = 文件的总长度.

    开始的位置: 线程id * 每一块的大小;
    结束的位置: ((线程id + 1) * 每一块的大小) -1;
</code></pre></li>
</ol>
<pre><code>2). 开启多个线程分别下载属于自己的那一块
</code></pre><p>key: Range 请求头代表请求部分内容<br>value: bytes=5-9</p>
<p>注意使用Range字段返回值不是200, 是206</p>
<p>XUtils框架 封装了多线程下载.</p>
<p>android四大组件之一: acitivity<br>    1). 显式意图<br>        应用场景: 在一个应用程序内部中, 最常用的: setClass(this, SecondActivity.class);<br>        特点: 耦合性非常高.</p>
<pre><code>2). 隐式意图
    应用场景: 在不知道某一个activity的类名, 包名, 并且引用不到时. 注意: data和type不可以分开设置. 调用setDataAndType
    特点: 耦合低

3). Intent传递数据.

4). Intent返回数据.

5). Activity生命周期.
    onPause 方法: 在activity被另一个activity给盖住时(盖住一部分), 调用onPause, 跑到暂停状态.
    onResume方式: 在onPause状态时, 把activity上的界面给关掉就返回到, 焦点状态onResume
    onStop方法: 当activity在焦点时, 有一个界面把当前的activity完全盖住. 进入到此状态
    onRestart方法: 当activity处于停止状态时, 把上面的activity给关掉, 这时候会调用 onRestart -&gt; onStart -&gt; onResume


        应用场景: onCreate  方法: 初始化界面需要的各种各样的参数.
              onDestory 方法: 释放资源.

              onResume  方法: 界面获取焦点时回调.  操作: 开始让界面动起来.
              onPause   方法: 来一个界面盖住了一部分的activity.  操作: 停止动态刷新的数据.

6). 横竖屏切换Activity的生命周期.
    默认情况下: 重新加载activity, 具体流程:
                onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume 最终获取焦点.
    在清单文件中actiivty的节点中加: android:configChanges=&quot;orientation|keyboardHidden&quot;
    就不会重新创建activity.

7). 任务栈(Tasks and Back Stack).
    为了提高用户体验.

    一个应用程序包含多个activity.

    栈的顶部的activity会在界面上显示, 获取焦点.

    任务栈的特点: 先进后出. 后进先出.


8). Android下的Activity启动模式.
</code></pre><p>Uri: 统一资源标识符  URL: 统一资源定位符  http://  https://  ftp</p>
<p>0208</p>
<p>任务栈: 提升用户体验.</p>
<ol>
<li>先进后出.</li>
<li>任务栈存放着所有的activity.</li>
<li>应用程序启动时, 默认情况下, 开启一个任务栈.</li>
<li>任务栈的id号, 是由系统维护的, 自增长的.</li>
</ol>
<p>问题: 页面开启过多, 返回需要点击多次.</p>
<p>启动模式:</p>
<p>standard 标准模式(activity默认的): 每次调用startActivity, 都会把activity给创建.</p>
<p>singleTop 单一顶部模式: 每次调用startActivity, 需要判断当前的activity是否已经被创建过并且查看任务栈的顶部是否是当前的    activity, 如果是, 调用onNewIntent方法, 如果不是, 就创建一个新的activity实例.</p>
<pre><code>应用场景: 非法程序员, 写的流氓程序, 一直在弹出某个页面.
</code></pre><p>singleTask 单一任务栈模式: 如果任务栈中已经存在当前activity, 再去调用startActivity, 会调用当前任务栈的onNewIntent方法. 同时    , 会把所有以上的activity都给清除出栈.</p>
<pre><code>应用场景: 如果一个界面显示的资源非常大, 只需要初始化一次实例.
</code></pre><p>singleInstance 单一实例模式: activity会在一个新的任务栈中实例化, 并且其他的activity不会创建在新的任务栈中. 始终在整个系统中    会被初始化一次.</p>
<pre><code>应用场景: 在整个系统中, 只需要初始化一次的页面.
</code></pre><p>Android四大组件:<br>Activity 显示界面<br>ContentProvider 内容提供者.<br>BroadcastReceiver 广播接收者<br>Service 服务</p>
<p>电台: 广播信息.</p>
<p>收音机: 接收广播信息.</p>
<p>广播有两种:</p>
<pre><code>无序广播: 新闻联播, 村里的大喇叭.

有序广播: 中央下达下来的任务.
    在清单文件中注册广播, 有先后顺序, 相同优先级的情况下在上面注册的广播要先收到广播.
    优先级的取值范围: -1000 到 1000;  1000优先级最高.
</code></pre><p>接收系统的广播: 电量低, sd卡卸载, 来短信, 打电话. 开机启动时.</p>
<p>IP拨号器.</p>
<p>重启手机: adb shell reboot</p>
<p>Service 服务: 无页面.长期在后台运行的一个组件. Thread</p>
<p>new Thread().start();</p>
<p>当我们把一个应用程序关掉时, 应用程序进程没有被回收掉, 而是编程了一个空进程.</p>
<p>进程的优先级, 提供系统回收进程的一套方案. 从高到低回收进程.</p>
<ol>
<li><p>Foreground process 前台进程.    用户正在操作的.</p>
</li>
<li><p>Visible process 可视进程.  不能直接操作, 并且没有获取焦点. 但是可以看到的应用.</p>
</li>
<li><p>Service process 服务进程. 在后台长期运行, 没有界面的进程.</p>
</li>
<li><p>Background process 后台进程.    当我们打开一个应用程序, 没有关闭它, 点击home键, 托管到后台.</p>
</li>
<li><p>Empty process 空进程. 当我们把一个应用程序关掉后, 系统没有立刻的把进程给回收掉, 这时候进程中没有组件, 变成空进程.</p>
</li>
</ol>
<p>android系统做了一个优化, 当特殊情况下, 需要回收service process, Visible process, Foreground process 进程时,<br>回收后, 当系统内存够用会把杀死的进程重新启动.</p>
<p>只有用户手动的把服务给关闭掉, 那么服务才会真正的销毁. 如果用户没有手动关闭, 服务会一直运行在系统中.</p>
<p>Service 开启方式有两种:</p>
<p>第一种: 开启完服务之后, 就跟服务没关系了. 不管服务的死活了.<br>    startService    开启服务, 生命周期显示: onCreate -&gt; onStartCommand    服务正在运行了.<br>            当服务已经在后台运行, 无论调用多少次startService都不会重新创建服务, 而是调用onStartCommand</p>
<pre><code>stopService    停止服务 当服务正在后台运行, stopService会把服务关掉, 生命周期: onDestory

这种方式开启服务, 不可以调用服务中的方法.
</code></pre><p>第二种: 可以调用服务中的方法, 当前的activity开启的service, 它俩的关系是, 不求同时生, 但求同时挂.<br>    bindService    绑定服务<br>            生命周期: onCreate -&gt; onBind 服务正在运行了.</p>
<pre><code>unbindService    解绑服务.
        生命周期: onUnbind -&gt; onDestory 服务被销毁了.


调用服务中的方法:
    1. 调用bindService方法, 绑定服务. 同时传递过去一个ServiceConnection连接桥. 并实现其中两个方法onServiceConnected.

    2. 自定义一个实现IBinder对象或者继承Binder类, 在onBind方法中返回这个对象.

    3. ServiceConnection连接桥中的onServiceConnected方法会被调用, 其中有个对象IBinder service, 就是服务返回来的对象

    4. 在自定义的类中写个方法, 转调服务中的方法.

    5. 在activity中拿着服务连接桥返回过来的对象, 调用服务中的方法.
</code></pre><p>远程服务调用:<br>    IPC: intel-process communication  因特尔进程间通信.<br>    AIDL android interface dinfiend language 安卓接口声明语言.  不允许接收修饰词.</p>
<pre><code>Binder类是实现了IBInder接口的类.


1. 在远程服务的应用程序中定义一个接口类, 把修饰词去掉. 把后缀名改成aidl

2. 如果没有错误, 会在我们的Gen目录下生成一个文件接口名.java

3. 在我们的服务中创建一个内部类, 继承gen目录下生成的接口文件中的Stub类.

4. 在Stub实现类中写一个方法, 用于转调服务中的买票方法.            

5. 在清单文件中service的节点下加隐式跳转的action参数. 用于让远程服务调用我们.        ---------------服务端基本完成.

6. 在另一个应用程序中调用bindService方法绑定服务. 并且传递过去一个ServiceConnection连接桥.

7. 把远程服务中的aidl文件拷贝到我们应用程序中. 新建一个和aidl包名一样的包, 放进去. 这时候gen目录下会生成对应的接口名.java的文件.

8. 在ServiceConnection连接桥的onServiceConnected方法中, 把服务返回过来的IBinder对象转换成IRemoteService对象.
    IRemoteService iRemoteService = Stub.asInterface(service);

9. 拿着获取的    iRemoteService  对象调用服务中的方法.
</code></pre><p>混合开启服务方式:   开启一次服务, 服务就一直在后台运行. 别人过来绑定就可以随便使用, 解绑之后也不会把服务关闭掉.</p>
<p>startService    服务在后台运行</p>
<p>捕鱼达人: 绑定, 付钱, 解绑<br>植物大战僵尸: 绑定, 付钱, 解绑<br>找你妹: 绑定, 付钱, 解绑<br>…….</p>
<p>在工作中, 如果写一个服务, 需要被别人调用, 并且还需要长期在后台运行. 就采用混合开启服务的方式运行服务.</p>
<p>0210</p>
<p>android系统会尽量长期的保留应用程序的进程。</p>
<p>只有系统内存严重不足的时候 回收进程。</p>
<p>1.前台进程<br>2.可见进程<br>3.服务进程<br>4.后台进程<br>5.空进程</p>
<p>有责任感的程序员不写流氓代码。</p>
<p>样式和主题。<br>style theme</p>
<p>样式和主题没有本质区别 写法都是完全一样的。</p>
<p>区别：作用范围不同。<br>样式：只能作用的控件上，textview imageview button，在布局文件中使用<br>主题：作用在activity上，或者正在应用程序上，在清单文件中配置</p>
<p>0301</p>
<p>1、对前面知识的综合应用，复习基础一遍。<br>2、熟悉代码，找到敲代码的感觉；<br>3、每天会有1000-1500行代码量；这几天下来一共就会有1万多行代码量。<br>4、大学软件工程的学生毕业要求3-5万行的代码量。10几天完成三分之一、五分之一；<br>5、版本控制，每一天的代码用版本控制起来，可以看到每天的代码；<br>6、演示程序代码。<br>7、演示功能有：<br>   启动页面<br>   主页<br>   手机防盗（注意：演示时模拟器要提前设置有联系人）；<br>   通讯卫士：黑名单的管理：电话拦截、短信拦截的演示；<br>   软件管理：列出系统的所以软件，启动软件、卸载软件、系统的卸载失败（需要root权限这个后面也会介绍）<br>   进程管理：列出系统中正在运行的程序；演示杀死软件<br>   窗口小部件：添加桌面；<br>   流量统计：模拟器并不支持，在真机上才能演示，只做个UI效果；<br>   手机杀毒：检查手机安装的软件，发现那个是病毒，提醒用户就杀掉；<br>   系统优化：清楚系统的垃圾，刚开始运行，没用多余数据；<br>   高级工具：归属地查询；常用号码查询；短信备份；</p>
<p> 注意：项目中差一个address.db数据库文件</p>
<p><a href="https://192.168.1.3/svn/heima24" target="_blank" rel="external">https://192.168.1.3/svn/heima24</a></p>
<p>1、按照模块 组织代码的包结构。 业务之间彼此独立；</p>
<p>办公软件</p>
<pre><code>--  开会。                com.itheima.meeting
--  发放工资。           com.itheima.money
--  出差。             com.itheima.travel
</code></pre><p>车载电脑</p>
<pre><code>-- 多媒体        
-- 导航        
-- 领航
-- obd模块
</code></pre><p>2、按照代码的类型组织包结构；<br> 界面        com.itheima.mobilesafe.activies<br> 自定义UI    com.itheima.mobilesafe.ui<br> 业务逻辑代码   com.itheima.mobilesafe.engine    数据引擎业务逻辑 获取解析数据<br> 持久化     com.itheima.mobilesafe.db<br>         com.itheima.mobilesafe.db.dao<br> 广播接收者     com.itheima.mobilesafe.receiver<br> 长期在后台运行 com.itheima.mobilesafe.service<br> 公用的api工具类com.itheima.mobilesafe.utils</p>
<p>splash界面的作用<br>1、用来展现产品的Logo；<br>2、应用程序初始化的操作；<br>3、检查应用程序的版本；<br>4、检查当前应用程序是否合法注册；</p>
<p>adb devices</p>
<p>afinal 支持断点续传</p>
<p>简介afinal是一个开源的android的orm和ioc应用开发框架，其特点是小巧灵活，代码入侵量少。<br>在android应用开发中，通过afinal的ioc框架，诸如ui绑定，事件绑定，通过注解可以自动绑定。通过afinal的orm框架，无需任何配置信息，一行代码就可以对android的sqlite数据库进行增删改查操作。同时，afinal内嵌了finalHttp等简单易用的工具，可以轻松的对http请求进行操作。<br>最新版本为0.3.5，发布于2013年04月02日[1]。<br>2主要组件FinalHttp：用于请求http数据，直接ajax方式请求，文件上传， 断点续传下载文件等<br>　　FinalBitmap：用于显示bitmap图片，而无需考虑线程并发和oom等问题。<br>　　FinalActivity：完全可以通过注解方式绑定控件和事件，无需编写代码。<br>　　FinalDb：android中sqlite的orm框架，一行代码搞定增删改查。<br>3特点设计简单小巧灵活<br>orm零配置，但可以配置，可以通过灵活的注解配置达到更加强大的功能<br>数据库查询支持DbModel，可以轻松的进行各种复杂的查询<br>android的ui和事件绑定完全通过注解的方式，无需编写一行代码<br>http请求支持ajax方式请求<br>体积小（不到100KB），不依赖第三方jar包</p>
<p>在Android系统中只能存在一个相同的包名；</p>
<p>假如应用A它的包名：com.itheima.mobilesafeA;<br>它已经在系统中了。</p>
<p>这个时候，我在想去安装B应用，刚好的它的包名也叫：com.itheima.mobilesafeA</p>
<p>会去检查它们的签名是否相同<br>如果相同，就覆盖安装；<br>如果不相同，就会安装失败；</p>
<p>要想应用替换安装成功 必须包名相同&amp;签名相同</p>
<p>Splash页面的作用它是我们软件的第一个页面</p>
<p>1.显示logo,加深记忆；</p>
<p>2.数据初始化操作；</p>
<p>3.检查更新；</p>
<p>4.校验软件的合法性；<br>5.校验网络</p>
<p>包的结构一般来说有两种</p>
<p>1.安装模块 组织代码的包结构。各个模块之间的业务逻辑彼此独立；</p>
<p>黑马科技有限公司 www.itheima.com</p>
<pre><code> 办公软件
    ----开会    com.itheima.meeting
    ----发工资    com.itheima.money
    ----出差    com.itheima.travel
风行网 www.funshion.com
</code></pre><p>   播放器</p>
<pre><code>----播放器    com.funshion.android.player
----下载    com.funshion.android.download
----联网    com.funshion.android.net
----工具包    com.funshion.android.utils
</code></pre><p>2.按照类型 组织代码的包结构。<br>        —-页面    com.itheima.mobilesafe.activity<br>        —-自定义UI    com.itheima.mobilesafe.ui<br>        —-业务逻辑    com.itheima.mobilesafe.engine<br>        —-持久化    com.itheima.mobilesafe.db<br>                com.itheima.mobilesafe.dao<br>        —-后台服务    com.itheima.mobilesafe.service<br>        —-广播接收者    com.itheima.mobilesafe.receiver<br>        —-公共的API     com.itheima.mobilesafe.utils</p>
<p>04-06 06:58:16.360: E/AndroidRuntime(2234): android.view.WindowManager$BadTokenException: Unable to add window – token null is not for an application</p>
<p>对话框它是我们的Activity的一部分<br>对话框它挂载在我们的Activity上；</p>
<p>getApplicationContext()这个方法得到的是Context<br>SplashActivity.this 得到Context的一个子类</p>
<p>也就是说 SplashActivity.this 相当于是getApplicationContext()的子类</p>
<p>基础班</p>
<p>父类有的子类一定有  - 没有有 token<br>子类有的父类不一定有 –有 token</p>
<p>this 还有Activity.this和我们的getApplicationContext()；</p>
<p>大多数情况推荐：Activity.this</p>
<p>如何做到覆盖安装</p>
<p>在Android系统里，只能存在一个包名的应用；</p>
<p>例如，A程序开发一款A软件软件 com.itheima.a;<br>小米手机<br>先安装在我们的手机上</p>
<p>B程序员开发了一款软件B软件 com.itheima.a;</p>
<p>小米手机（Android系统）</p>
<p>1.先校验是否有相同包名的应用；<br>2.是否签名一样；</p>
<p>如果签名一样，就安装成功；如果签名不一样，就安装失败；</p>
<p>我们直接在开发环境中运行的软件也是签名的 ： 默认签名</p>
<p>而我们服务器上的签名是一个正式的签名，所有默认签名是无法覆盖正式签名的</p>
<p>默认的签名覆盖默认是可以的。</p>
<p>正式签名后，就可以在各个应用市场发布了；</p>
<p>问题：如果密钥丢了怎么办？</p>
<p>1.重新创建密钥；—无法覆盖安装；–</p>
<p>2.重新改包名 —重新 —- com.itheima.aa—优化–写一个代码吧老版本卸载掉</p>
<p>总结一下自定义属性的过程</p>
<p>1，声明一个View对象，这个view继承相对布局，或者线性布局；ViewGroup；<br>2, 实现父类（相对布局）的构造方法，并且在构造方法里初始化布局；<br>3,跟新需要和业务逻辑，增加一些api方法，扩展自定义组合控件。</p>
<p>4，要自定义属性；<br>5，自定义一个命名空间 <a href="http://schemas.android.com/apk/res/com.itheima.mobilesafe；" target="_blank" rel="external">http://schemas.android.com/apk/res/com.itheima.mobilesafe；</a><br>6, 在res的values目录下描述自定义属性的文件<br>  <declare-styleable name="SettingItemView"><br>        <attr name="desc_on" format="string"><br>        <attr name="desc_off" format="string"><br>        <attr name="title" format="string"><br>    </attr></attr></attr></declare-styleable></p>
<p>7，在布局文件里写你要用的哪些属性<br>8，在只有两个参数的构造方法里 有一个类AttributeSet attrs 封装了所以属性的信息。<br> 获取自定义的属性信息。</p>
<p>0302</p>
<p>我们在世面上买来的手机，一般是没有root权限的；</p>
<p>root权限：我们Linux下超级管理员权限</p>
<p>如果想获得root权限？</p>
<p>如果真机获得了root权限</p>
<p>md5加密</p>
<p>明文 —》密文<br>123456 –》 d’fd;jjklllllllk; 不可逆</p>
<p>123456—c56d0e9a7ccec67b4ea131655038d604<br>c56d0e9a7ccec67b4ea131655038d604—c56d0e9a7ccec67b4ea131dd655038d604<br>444-c56d0e9a7ccec67b4ea131655038d604<br>字典，查数据库的操作</p>
<p>root权限<br>买过来的手机是没有root权限的；<br>linux系统的超级管理员权限；</p>
<p>如果你的手机刷机了，那就有</p>
<p>模拟器能看到data/data里的数据<br>没有root权限的手机是看不到data/data</p>
<p>有root权限的符号：#<br>没有root权限的符号：&amp;</p>
<p>查看config.xml命令<br>cat config.xml</p>
<p>md5算法：</p>
<p>不可逆的 ：原文 –》密文</p>
<p>123456 —》e10adc3949ba59abbe56e057f20f883e</p>
<p>二进制数的加法和乘法运算如下：<br>0+0=0 0+1=1+0=1 1+1=10<br>0×0=0 0×1=1×0=0 1×1=1</p>
<p>二进制数、转换为十进制数的规律是：把二进制数按位权形式展开多项式和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”.</p>
<p>一、整数的</p>
<p>例如:把(1001)2转换为十进制数。</p>
<p>解：（1001）2<br>=1×（2的3次方）+0×（2的2次方）+0×（2的1次方）+1×（2的0次方）<br>=8+0+0+1<br>=9</p>
<p>二、有小数的</p>
<p>解：（1001.01）2<br>=1×（2的3次方）+0×（2的2次方）+0×（2的1次方）+1×（2的0次方）+0×（2的-1次方）+1×（2的-2次方）</p>
<p>=8+0+0+1+0.5+0.25</p>
<p>=9.75</p>
<p>二进制与十六进制的关系</p>
<p>2进制 0000 0001 0010 0011 0100 0101 0110 0111<br>16进制 0    1    2    3    4    5    6    7<br>2进制 1000  1001  1010   1011   1100   1101   1110   1111<br>16进制 8     9    a(10)  b(11)  c(12)  d(13)  e(14)  f(15)</p>
<p>可以用四位数的二进制数来代表一个16进制，如3A(16) 转为二进制为：<br>3为0011，A 为1010，合并起来为00111010。可以将最左边的0去掉得1110102<br>右要将二进制转为16进制，只需将二进制的位数由右向左每四位一个单位分隔，将各单位对照出16进制的值即可。</p>
<p>十六进制数的第0位的权值为16的0次方，第1位的权值为16的1次方，第2位的权值为16的2次方……<br>  所以，在第N（N从0开始）位上，如果是是数 X （X 大于等于0，并且X小于等于 15，即：F）表示的大小为 X <em> 16的N次方。<br>  假设有一个十六进数 2AF5, 那么如何换算成10进制呢？<br>  用竖式计算： 2AF5换算成10进制:<br>  第0位： 5 </em> 16^0 = 5<br>  第1位： F <em> 16^1 = 240<br>  第2位： A </em> 16^2 = 2560</p>
<h2 id="第3位：-2-16-3-8192-＋"><a href="#第3位：-2-16-3-8192-＋" class="headerlink" title="  第3位： 2 * 16^3 = 8192 ＋"></a>  第3位： 2 * 16^3 = 8192 ＋</h2><p>  10997<br>  直接计算就是：<br>  5 <em> 16^0 + F </em> 16^1 + A <em> 16^2 + 2 </em> 16^3 = 10997</p>
<p>  得到SIM卡</p>
<p>第一节课<br>1、设置密码对话框；<br>2、密码登录框；<br>第二节课<br>3、单独Java工程演示MD5加密算法；<br>4、破解MD5演示—需要网络（www.cmd5.com盈利10万每天）<br>5、移植到Android工程里<br>6、手机防盗页面LoastActivity<br>7、设置向导第一个页面；<br>8、自定义button样式；<br>9、状态选择器</p>
<p>自定义组合控件的过程</p>
<p>1.自定义一个View对象，继承相对布局或者线性布局，必须是ViewGroup子类；<br>2.实现View对象的3个构造方法呀；在构造方法里面初始化布局文件；<br>3.我们要根据一些需求或者业务，增加一些API方法；<br>——以上3步就是自定义组合控件；</p>
<p>4.根据需求，我们想更加方便，所有要自定义属性；<br>5.自定义命名空间；<br>例如：<br> xmlns:xxxxxxx=”<a href="http://schemas.android.com/apk/res/《包名》" target="_blank" rel="external">http://schemas.android.com/apk/res/《包名》</a>“<br> xmlns:itheima=”<a href="http://schemas.android.com/apk/res/com.itheima.mobilesafe" target="_blank" rel="external">http://schemas.android.com/apk/res/com.itheima.mobilesafe</a>“</p>
<p>6.自定义属性res/values/attrs.xml里面定义属性：<br>例如：<br>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
<resources><br>    <declare-styleable name="SettingItemView"><br>        <attr name="title" format="string"><br>        <attr name="desc_off" format="string"><br>        <attr name="desc_on" format="string"><br>    </attr></attr></attr></declare-styleable><br></resources>


<p>7.使用我们自定义属性<br>例如：<br>     itheima:desc_off=”设置自动更新已经关闭”<br>        itheima:desc_on=”设置自动更新已经开启”<br>        itheima:title=”设置自动更新”</p>
<p>7.我们布局文件定义控件的时候，初始化控件是用我们带有两个参数的构造方法，属性值就放在AttributeSet attrs，我们就把里面的属性取出来，放在我们的布局文件对应的控件上；<br>例如：取出来：<br>String title = attrs.getAttributeValue(<br>                “<a href="http://schemas.android.com/apk/res/com.itheima.mobilesafe" target="_blank" rel="external">http://schemas.android.com/apk/res/com.itheima.mobilesafe</a>“,<br>                “title”);</p>
<p>例如：如何关联</p>
<pre><code>setTitle(title);
</code></pre><p>0303</p>
<p>1、网络定位（network）。前提是必须连上网络：wifi、3G、2G；<br> 获取到IP地址<br> 例如：彩虹版QQ，珊瑚虫版QQ，就有一个功能显示对方的IP；<br> 根据IP显示具体的位置；</p>
<p> 原理是建立一个库那个IP地址对应那个地方；早期警方破案就采用此特点；</p>
<p> 有局限性：针对固定的IP地址。<br> 如果手机网或者ip地址是动态分布IP，这个偏差就很大。这种情况是无法满足需求的。</p>
<p>2、基站定位（passive<br>）。</p>
<p>工作原理：手机能打电话，是需要基站的。手机定位也是用基站的。<br>手机附近能收到3个基站的信号，就可以定位了。<br>基站定位有可能很准确，比如基站多的地方；<br>如果基站少的话就会相差很大。<br>精确度：几十米到几公里不等；</p>
<p>3、GPS定位(gps)。<br>A-GPS 使用了卫星定位 需要联网辅助修正位置<br>特点是：需要搜索卫星， 头顶必须是空旷的；</p>
<p>影响条件：云层、大厦、大树。</p>
<p>卫星：美国人、欧洲人的卫星。<br>北斗：中国的，但没有民用，只是在大巴，战机等使用。</p>
<p>我知道有 四维图新、高德、易图通、凯立德、道道通、灵图等国内六七家导航地图软件厂商<br>市面比较常见的主要是凯立德、道道通</p>
<p>当前，中国取得导航电子地图资质的有：四维图新、高德、灵图、畅想，瑞图万方、武汉吉奥、凯立德、易图通，这八家企业。<br>而四维跟易图通这两家企业只从事数据采集而并不自己设计导航软件！<br> 每个地图厂商设计的导航软件各有不同，像凯立德是在大众GPS导航消费领域排行老大，道道通在中国导航电子地图表现得也比较活跃……..</p>
<p>中国当然有啊  目前已经投入使用的卫星定位系统主要有美国的GPS系统、俄罗斯的格洛纳斯系统和中国的北斗系统，即将投入使用的是欧盟和中国合作开发的伽利略系统。</p>
<p>中国于2003年加入伽利略计划，计划投资超过两亿欧元，并将参加卫星研发、用户服务等全部过程，既是参与者，也是拥有者。在与欧盟合作交流的同时，我国的北斗定位系统已日渐成熟，也将逐步扩展为全球卫星定位系统。</p>
<p>设备超级管理员</p>
<p>device admin</p>
<p>华为：上班前所有员工都把手机上交放在篮子里；<br>目的：防止一些机密文件被拷贝走；<br>     1、USB接口不可用，或者不设置USB接口；<br>     2、不可以上外网；—-》单独的上网的机子；</p>
<p>国外：</p>
<p>国家保密插件，也叫做加密插件或者加偏或者SM模组，其实就是对真实坐标系统进行人为的加偏处理，按照几行代码的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被人称为火星坐标系统。<br>国家保密插件，也叫做加密插件或者加偏或者SM模组，其实就是对真实坐标系统进行人为的加偏处理，按照几行代码的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被人称为火星坐标系统。<br>所有的电子地图所有的导航设备，都需要加入国家保密插件。第一步，地图公司测绘地图，测绘完成后，送 到国家测绘局，将真实坐标的电子地图，加密成“火星坐标”，这样的地图才是可以出版和发布的，然后才可以让GPS公司处理。第二步，所有的GPS公司，只要需要汽车导航的，需要用到导航电子地图的，统统需要在软件中加入国家保密算法，将COM口读出来的真实的坐标信号，加密转换成国家要求的保密的坐标，这样，GPS导航仪和导航电子地图就可以完全匹配，GPS也就可以正常工作。</p>
<p>四大组件：<br>Activity –显示页面的<br>Service –后台运行的服务<br>Content Provider</p>
<p>Broadcast Receiver</p>
<p>广播接收者 不光可以在功能清单文件注册</p>
<p>还可以在代码里面注册</p>
<p>android 4.2 接收短信如何实现</p>
<p>0305</p>
<p>点击事件 -按下 –停留 -离开  ： 按下-离开</p>
<p>双击事件：单位时间内（500） ，连续点击两次，才是双击事件。</p>
<p>1.第一次点击的事件的时间<br>2.记录第二次点击事件的时间</p>
<p>三击事件 ；单位时间内，连续点击三次，才是三击事件；</p>
<p>触摸事件包含 触碰 移动  离开-瞬间</p>
<p>点击事件 一组连续的动作 - 必须包含:按下 -停留 -离开</p>
<p>电阻触屏俗称“软屏”，多用于Windows Mobile系统的手机；电容触屏俗称“硬屏”，如iPhone和G1等机器采用这种屏质的。</p>
<p>一、室内可视效果<br>两者通常很好。</p>
<p>二、触摸敏感度<br>1、电阻触屏：需用压力使屏幕各层发生接触，可以使用手指（哪怕带上手套），指甲，触笔等进行操作。支持触笔在亚洲市场很重要，手势和文字识别在哪里都被看重。<br>2、电容触屏：来自带电的手指表层最细微的接触也能激活屏幕下方的电容感应系统。非生命物体、指甲、手套无效。手写识别较为困难。</p>
<p>三、精度<br>1、电阻触屏：精度至少达到单个显示像素，用触笔时能看出来。便于手写识别，有助于在使用小控制元素的界面下进行操作。<br>2、电容触屏：理论精度可以达到几个像素，但实际上会受手指接触面积限制。以至于用户难以精确点击小于1cm2的目标。</p>
<p>四、成本<br>1、电阻触屏：很低廉。<br>2、电容触屏：不同厂商的电容屏价格比电阻屏贵10%到50%。这点额外成本对旗舰级产品无所谓，但可能会让中等价位手机望而却步。</p>
<p>五、多点触摸可行性<br>1、电阻触屏：不可能，除非重组电阻屏与机器的电路连接。<br>2、电容触屏：取决于实现方式以及软件，已在G1的技术演示以及iPhone上实现。G1的1.7T版本已经可以实现浏览器的多点触摸特性。</p>
<p>六、抗损性<br>1、电阻触屏：电阻屏的根本特性决定了它的顶部是柔软的，需要能够按下去。这使得屏幕非常容易产生划痕。电阻屏需要保护膜以及相对更频繁的校准。有利的方面是，使用塑料层的电阻触屏设备总体上更不易损，更不容易摔坏。<br>2、电容触屏：外层可以使用玻璃。这样虽然不至于坚不可摧，而且有可能在严重冲击下碎裂，但玻璃应对日常碰擦和污迹更好。</p>
<p>七、清洁<br>1、电阻触屏：由于可以使用触笔或指甲进行操作，更不容易在屏幕上留下指纹、油渍和细菌。<br>2、电容触屏：要用整个手指进行触摸，但玻璃外层更容易清洁。</p>
<p>八、环境适应性<br>1、电阻触屏：具体数值不得而知。但有证据表明使用电阻屏的Nokia 5800可以在-15°C至+45°C的温度下正常工作，对湿度也没什么要求。<br>2、电容触屏：典型的操作温度在0°至35°之间，需要至少5%的湿度(工作原理所限)。</p>
<p>九、阳光下可视效果<br>1、电阻触屏：通常很糟，额外的屏幕层面反射了大量阳光。</p>
<p>0306</p>
<p>所有常见的电话手机呼叫转移设置方法</p>
<pre><code> 固定电话 座机呼叫转移设置（中国电信呼叫转移设置、中国网通固定电话呼叫转移）：
【无条件转移】设定：*57*电话号码#　　取消：#57#
【无应答转移】设定：*41*电话号码#　　取消：#41#
【遇忙转移】　设定：*40*电话号码#　　取消：#40#

 小灵通呼叫转移设置：
【无条件转移】设定：*57*电话号码#　　取消：#57#
【无应答转移】设定：*41*电话号码#　　取消：#41#
【遇忙转移】　设定：*40*电话号码#　　取消：#40#
【不可及转移】设定：*45*电话号码#      取消：#45#
（有的地方可能是42，具体咨询当地10000）

 GSM手机 电话呼叫转移到手机（中国移动、中国联通 大多数用户）：(设置空号后，系统提示拨叫的是空号)
【无条件转移】设定：**21*电话号码#　  取消：##21#
【无应答转移】设定：**61*电话号码#　  取消：##61#
【遇忙转移】　设定：**67*电话号码#     取消：##67#

 CDMA手机（中国联通用户）：
【无条件转移】设定：*72电话号码　　　取消：*720
【无应答转移】设定：*92电话号码　　　取消：*920
【遇忙转移】　设定：*90电话号码　　　取消：*900

 下面是铁通固定电话转移设置、铁通呼叫转移设置、 固定电话转移设置、铁通电话呼叫转移：
1 铁通固定电话 无应答转移
登记:拨号,*41*TN#
取消:拨号,#41#
2 铁通固定电话 遇忙转移
登记:拨号,*40*TN1#
取消:拨号,#40#
3 铁通固定电话 无条件转移
登记:拨号,*57*TN#
取消:拨号,#57#
</code></pre><p>业务说明</p>
<p>呼叫转移的类型有4种：</p>
<p>不可及转移：关机或没有信号时转移</p>
<p>无应答转移：响铃超过三声无人接听时转移</p>
<p>遇忙转移：占线时转移</p>
<p>无条件转移：所有来电转移</p>
<p>所有来电转移、不可及转移属无条件转移；遇忙、无应答转移属于有条件转移<br>业务资费</p>
<p>1、自08年4月1日起，呼叫转移基本费统一调整为：呼转基本费为0.1元/分钟；</p>
<p>2、非漫游状态下：</p>
<p>呼叫转移的计费原则均按：呼转基本费（0.1元/分钟）+归属地至前转地的长途费用</p>
<p>3、漫游情况下：</p>
<p>国内漫游时有条件转移计费原则：收取漫游费0.6元/分钟（一口价，不区分被叫用户漫游及呼转情况）。</p>
<p>国内漫游时无条件转移计费原则：呼叫转移基本费（0.1元/分钟）＋归属地－前转地的长途费用。长途费用收费原则：归属地与前转地不在同一地的，收取长途费；归属地与前转地在同一地，不收取长途费。</p>
<p>备注：前转地是指呼转至的电话号码的归属地。特例：当两部手机漫游到同一城市，其中一部有条件呼转到另一部时，此时的前转地指呼转至的电话号码漫游地。<br>开通/取消方式</p>
<p>呼叫转移功能默认开通，无需申请。该业务无需取消。</p>
<p>操作方式</p>
<p>（1）通过手机菜单设置：进入呼叫转移的相应菜单，根据提示进行设置。</p>
<p>（2）登录互联网进行设置：登录互联网进入业务办理，输入服务密码后，进行相关设置。</p>
<p>（3）拨打10086进行设置：拨打10086，输入服务密码后，根据提示进行设置。（须与被转方联系确认）</p>
<p>（4）通过快捷方式设置：</p>
<p>在需呼转的手机上直接拨打以下呼叫转移类型相对应的设置或取消格式</p>
<p>a、当呼叫转移类型为不可及转移时，其设置方式为：<em>*62</em>号码#；其取消方式为：##62#；</p>
<p>b、当呼叫转移类型为无应答转移时，其设置方式为：<em>*61</em>号码#；其取消方式为：##61#；</p>
<p>c、当呼叫转移类型为遇忙转移时，其设置方式为：<em>*67</em>号码#；其取消方式为：##67#；</p>
<p>d、当呼叫转移类型为无条件转移时，其设置方式为：<em>*21</em>号码#；其取消方式为：##21#；</p>
<p>取消设置的所有呼叫转移：##002#</p>
<p>特别提醒：不需要呼叫转移时，请您及时取消</p>
<p>只有具有国际长权的中国移动“全球通”用户才能设置并使用国际及港澳台呼转业务，其他中国移动用户虽然能够设置，但不能呼转成功。</p>
<p>客户可以在境内归属地或漫游状态下设置有条件或无条件呼转国际及港澳台电话。但由于境外移动运营商网络配置等问题，不能保证用户在境外能够设置成功并使用有条件呼转业务。<br>疑难解答</p>
<p>1、我的手机状态正常，可以拨打电话，为什么别人拨我电话时听到空号的录音？</p>
<p>答：可能是您无意中设置呼转至空号上，您可拨打##002#取消呼叫转移。</p>
<p>2、是不是我的手机只要设置呼叫转移功能，都无法接听电话了？</p>
<p>答：不是，目前我司提供了四种“呼叫转移”的类型，无条件呼叫转移、关机及不可及呼叫转移、遇忙呼叫转移、无应答呼叫转移，您可根据您需要的情况设置呼叫转移。</p>
<p>3、我能不能同时设置所有类型的呼叫转移？</p>
<p>（1）关机及不可及转移、遇忙转移和无应答转移三种方式中，客户可以同时设置一种或数种呼叫转移方式。</p>
<p>（2）无条件转移具有最高优先级、当您设置此项功能后，另三种转移功能自动失效。</p>
<p>4、如果我设置了“无应答呼叫转移”，那么振铃后多长时间后会转移呢？</p>
<p>答：系统默认“无应答呼叫转移”的时长为30秒，如果您设置了无应答呼叫转移，那么振铃30秒后如果您仍没有接起，系统将会转移至您所设置的号码上。</p>
<p>5、我设置的转移号码可以是外地的电话吗？</p>
<p>答：可以，但您设置的转移号码如果是外地固定电话，需在固定电话号码前，加固定电话归属城市的区号。  </p>
<p>0307</p>
<p>我们开发项目的时候，一般是团队开发</p>
<p>A程序员负责写UI，界面。—进度框；</p>
<p>B程序员负责业务逻辑，短信备份具体的实现代码；</p>
<p>你给我暴露一个接口呗<br>我给你一个回调呗；</p>
<p>0308</p>
<p>1.当界面上第一个widget被创建的时候<br>04-19 06:35:09.236: I/System.out(520): onEnabled     当第一个widget被创建的时候调用的方法。 适合做widget的初始化。<br>04-19 06:35:09.236: I/System.out(520): onreceive     widget实际上是一个特殊的广播接受者。<br>04-19 06:35:09.396: I/System.out(520): onUpdate       当有新的widget被创建的时候调用。 当时间片到了的时候也会执行。<br>04-19 06:35:09.396: I/System.out(520): onreceive</p>
<p>2.当界面上第二个widget被创建<br>04-19 06:35:53.576: I/System.out(520): onUpdate<br>04-19 06:35:53.576: I/System.out(520): onreceive</p>
<p>3.以后再创建新的widget<br>04-19 06:36:21.526: I/System.out(520): onUpdate<br>04-19 06:36:21.536: I/System.out(520): onreceive</p>
<p>4.当一个widget被删除<br>04-19 06:36:44.966: I/System.out(520): onDeleted<br>04-19 06:36:44.976: I/System.out(520): onreceive</p>
<p>5.再去删除一个<br>04-19 06:36:44.966: I/System.out(520): onDeleted    有控件被删除调用<br>04-19 06:36:44.976: I/System.out(520): onreceive</p>
<p>6.最后一个被移除<br>04-19 06:37:16.466: I/System.out(520): onDeleted<br>04-19 06:37:16.466: I/System.out(520): onreceive<br>04-19 06:37:16.466: I/System.out(520): onDisabled    当最后一个widget被移除调用的方法。 清理扫尾操作。<br>04-19 06:37:16.466: I/System.out(520): onreceive</p>
<p>360桌面 腾讯桌面 awt桌面 go桌面 小米桌面 点心桌面 百度桌面</p>
<p>0309</p>
<p>计算机病毒 实际上是一个特殊的程序。</p>
<p>如果病毒不发作，只是一个硬盘上的特殊的文件。</p>
<p>杀毒软件： 找到这些文件，删除掉。</p>
<p>KV20 ： kill-virus 20 可以杀死20个病毒</p>
<p>分析提取这些病毒的特征码。<br>放到数据库里面。<br>互联网云安全计划。</p>
<p>病毒数据库 越来越大<br>只能查杀已知的病毒，不能查杀未知的病毒。</p>
<p>2千万条病毒特征码   多表 分级。</p>
<p>90万个文件。  .jpg .mp3 .txt  .dll .exe .cmd</p>
<p>杀毒引擎： 优化后的数据库查询算法。</p>
<p>主动防御：检测到未知的病毒。<br>看门狗。 后台一个死循环 while（true）</p>
<p>1.手机里面有多个任务栈在同时运行。<br>2.一般情况下，一个应用程序对应一个任务栈，特殊情况，如果有activity配置 singleinstance，这个activity会运行在自己单独的任务栈。</p>
<p>activity的启动模式：<br>1.standard       标准启动模式  后进先出的启动模式 适合绝大多数的应用场景<br>2.singletop      顶部单一   复用栈顶已经创建好的activity<br>3.singletask     任务栈单一  webkit html解析引擎 js解析引擎 css解析引擎 图片渲染引擎<br>4.singleinstance 单一实例 单例模式 单态模式 activity运行在自己单独的任务栈里面，并且只有一个实例存在</p>
<p>长按小房子：<br>显示出来用户最近操作的activity（不管这个activity是否已经关闭）</p>
<p>0310</p>
<ol>
<li>代码组织的方式  业务逻辑  代码的类型</li>
<li>PackageManager 包管理器 获取包信息</li>
<li>URL httpUrlConntion</li>
<li>Handler + message  子线程更新ui</li>
<li>json 解析。</li>
<li>创建对话框  AlertDialog.Builder</li>
<li>this 上下文 getApplicationContext（）；</li>
<li>afinal —&gt; Xutils</li>
<li>安装apk</li>
<li><p>应用程序的签名问题。 替换安装 签名和包名一致。</p>
</li>
<li><p>GridView 和 ListView  数据适配器。 getView getCount</p>
</li>
<li>滚动textview 重写父类的方法。自定义view对象</li>
<li>自定义对话框</li>
<li>状态选择器 xml selector</li>
<li>样式和属性。</li>
<li>抽取父类。 公共基类</li>
<li>手势识别器</li>
<li>自定义activity的切屏动画</li>
<li>TelephonyManager</li>
<li>内容提供者获取系统的联系人</li>
<li>startActivityForResult()</li>
<li><p>sharedperference 保存配置信息。</p>
</li>
<li><p>手机定位的方式 基站定位 wifi 网络定位 GPS定位</p>
</li>
<li>LocationManager 位置管理服务</li>
<li>火星坐标 - 地球坐标的转化</li>
<li>MediaPlayer.create()</li>
<li>DevicePolicyMangager 设备超级管理员</li>
<li>短信的广播接受者。</li>
<li><p>有序广播（可以拦截，可以终止） 无序广播 （不可以被拦截）</p>
</li>
<li><p>数据库的创建</p>
</li>
<li>数据库增删改查。</li>
<li>服务长期后台运行没有界面的组件。</li>
<li>TelephonyManager  监视手机通话的状态。</li>
<li>挂断电话。 反射调用隐藏API</li>
<li><p>内容提供者删除呼叫记录</p>
</li>
<li><p>使用外部的数据库。</p>
</li>
<li>SQLiteDataBase.open();</li>
<li>正则表达式。</li>
<li>抄APIDEMO 获取抖动效果</li>
<li>动画的插入器。</li>
<li>verbose服务。</li>
<li>自定义土司。</li>
<li>WindowManager 服务</li>
<li>触摸事件。 拖动的效果。</li>
<li>双击点击事件的实现。</li>
<li>自定义组合控件</li>
<li>自定义属性。</li>
<li>ExpendableListView</li>
<li>内容提供者访问短信 实现备份和还原。</li>
<li><p>接口和回调</p>
</li>
<li><p>PackageManger 获取应用程序图标 名称</p>
</li>
<li>复杂listview的显示。</li>
<li>复用历史缓存contentView</li>
<li>减少子孩子id查询的次数。 viewHolder</li>
<li>listview的滚动监听器。</li>
<li>listview的分批加载数据 、分页加载数据</li>
<li>limit offset 数据库分页查询</li>
<li>flags 获取应用程序的状态。</li>
<li>popupwindow</li>
<li>9path图形</li>
<li>动画效果 动画集合</li>
<li>卸载apk</li>
<li>启动apk</li>
<li><p>分享apk</p>
</li>
<li><p>activitymanager 活动管理器 类似电脑的进程管理器</p>
</li>
<li>/proc/cpuinfo /proc/meminfo</li>
<li>带checkbox的listview如何处理</li>
<li>am.killBackgoudProcess(packname);</li>
<li>widget创建</li>
<li>widget的生命周期函数。 onenable ondisable</li>
<li>RemoteViews 远程view’对象</li>
<li>PendingIntent 延期意图</li>
<li>自定义广播事件</li>
<li>Timer TimerTask 定期任务。</li>
<li>省电优化，锁屏广播事件。</li>
<li>借鉴金山的布局。反编译工具获取布局。</li>
</ol>
<ol>
<li>流量统计的原理 /proc/uid_stat/10085 tcp_rcv tcp_snd</li>
<li>TrafficStat</li>
<li><p>SlidingDrawer抽屉控件</p>
</li>
<li><p>杀毒软件的原理。</p>
</li>
<li>自定义动画</li>
<li>自定义进度条。</li>
<li>动态的更新界面。 添加TextView</li>
<li>横竖屏切换的生命周期。</li>
<li><p>提取文件的特征码 MD5</p>
</li>
<li><p>从Settings 寻找我们关心的代码。</p>
</li>
<li><p>利用反射获取隐藏的API</p>
</li>
<li><p>看门狗逻辑 死循环。</p>
</li>
<li>获取手机的任务栈</li>
<li><p>activity的启动模式 4种</p>
</li>
<li><p>activity和服务之间消息通讯（自定义广播）</p>
</li>
<li><p>程序优化。 细节处理。</p>
</li>
<li><p>程序混淆</p>
</li>
<li>异常处理</li>
<li><p>屏幕适配</p>
</li>
<li><p>添加广告条</p>
</li>
</ol>
<p>0501</p>
<p>root uid 0 gid0<br>system uid 1000 gid1000<br>shell  uid 2000 gid2000<br>app  uid &gt;10000 gid &gt;10000</p>
<p>jarsigner -verbose -keystore E:\Epan\huluxia.key -signedjar C:\Users\xuhaiyang\Desktop\admo\sing_4096.apk C:\Users\xuhaiyang\Desktop\admo\un4096.apk huluxia</p>
<p>adb 指令<br>adb devices<br>adb -s serialNumber shell<br>adb shell 进入手机管理<br>adb install apkpath  -r -f -s<br>adb uninstall apkpackname -k<br>adb push 电脑端文件路径  手机端文件路径<br>adb pull 手机端文件路径   电脑端文件路径<br>adb reboot  重启手机<br>adb reboot recovery 重启恢复模式<br>adb reboot bootloader 重启引导模式<br>adb wait-for-device<br>adb shell monkey -v -p com.tencent.mobileqq 500<br>adb forward tcp:1100 tcp:1200<br>adb shell getprop  获取手机参数</p>
<p>cat /proc/cpuinfo<br>adb shell dumpsys cpuinfo |notification| meminfo |cpuinfo 查看手机当前的cpu使用 notification使用 meminfo</p>
<p>1、手机截屏  screen sdk_version  filepath<br>2、手机字体修改  替换/system/fonts/DroidSansFallback.ttf （中文 ）文件 ，替换/system/fonts/DroidSans.ttf (英文文件)<br>3、卸载系统应用<br>(1)获取应用的路径 pm path packname<br>(2)移除apk rm  apkpath<br>(3)彻底删除残留文件  pm uninstall packnmae ;rm -r /data/data/packname;</p>
<p>4、结束系统进程<br>(1)ps<br>(2)kill pid<br>5、静默安装卸载<br>6、可以禁止开机启动项,冻结应用</p>
<p>7、屏幕解锁<br> rm /data/system/gesture.key;rm /data/syste/locksettings.<em>;<br>8、应用及应用数据的备份，移动应用到系统应用。<br> busybox cp -r -f -p -P source/</em>  des/<br>10、修改开机动画<br>替换 /system/media/bootaniation.zip(注意压缩时用winrar 压缩存储模式)<br> 三星官方系统 需要替换/system/bin/samsungani 为自己的 然后执行上面的步骤。<br>11、更换系统刷机</p>
<p>12.查看短信，联系人数据库</p>
<p>cat /data/data/com.android.providers.contacts/databases/contacts2.db &gt; /data/lcoal/tmp/1.db<br>adb pull /data/lcoal/tmp/1.db pc_path</p>
<p>cat /data/data/com.android.providers.telephony/databases/mmssms.db &gt; /data/lcoal/tmp/1.db<br>adb pull /data/lcoal/tmp/1.db pc_path</p>
<p>pm path packname 查看apk安装的路径<br>pm install -r -f -s apppath 安装apk，r 强制安装，f 安装手机内存 s 安装sdcard<br>pm uninstall -k packname 卸载应用 -k 保留应用数据 /data/data/packname下的数据 或者 /sdcard/Android/data/packnmae<br>pm enable packname 设置应用为不可用，或者组件不可用 组件跟类的完整路径<br>pm disable packname 设置应用可用<br>pm setInstallLocation 0 1 2  设置应用安装的默认目录 0 auto 1 手机内存 2 sdcard<br>pm getInstallLocation  查看当前设置<br>pm clear packname 清楚应用缓存数据</p>
<p>linux 常用指令：(权限)<br>busybox<br>rm  移除文件 或 文件夹 rm /data/local/tmp/1.apk<br>cd  进入目录 cd /data/local/tmp<br>cat 查看文件内容 cat /proc/cpuinfo  ; 复制文件  cat /data/local/tmp/1.apk &gt; /sdcard/1.apk<br>cp 复制文件  cp /data/local/tmp/1.apk /sdcard/1.apk<br>mv 移动文件，重命名文件  mv /data/local/tmp/1.apk /data/local/tmp/2.apk<br>chmod 为文件或目录赋权限  chmod 777 /data/local/tmp/1.apk<br>chown 为文件赋所属者 chown 0.0 /data/local/tmp/1.apk<br>echo 写入文件 如果文件不存在创建并写入 echo ‘111’ &gt; /sdcard/1111.txt<br>md5sum  获取文件md5码 md5sum /system/app/1.apk<br>halt 关机 不是所有手机都有此指令<br>reboot 重启手机<br>id    获取当前用户信息<br>touch  创建一个空文件 touch /data/local/tmp/1.txt<br>sleep  睡眠多少秒 sleep 10<br>mkdir  创建文件夹 mkdir /sdcard/nihao<br>ps     查看当前系统所有进程<br>kill  杀进程 kill 进程id<br>ls  列出当前文件夹下的文件</p>
<p>gzip ungzip<br>mount  挂载分区 mount -o remount rw /system<br>df  查看磁盘空间 df /system</p>
<p>app 权限 10000-<br>shell 权限2000<br>system 1000<br>root 0</p>
<p>1.adb 指令<br>  a.查看链接终端设备 adb devices<br>  b.进入设备终端 adb shell ;多台设备 adb -s 设备号 shell<br>  c.往手机放文件 adb [-s 设备号] push pc文件路径  手机path<br>  d.从手机往电脑获取文件 adb [-s 设备号] pull phone文件路径  pc_path<br>  e.安装，卸载应用 adb install[ -r 强制覆盖安装][-f 安装到手机内存 /data目录][-s 安装到sdcard /sdcard目录]  apk 路径 ；adb uninstall packname<br>     pm install -r -f -s 手机文件路径; pm uninstall -k packname</p>
<p>  f.冻结应用，开机启动项<br>    冻结    pm disable packname | 组件 ；解冻 pm enable packanme | 组件<br>    清楚数据 pm clear packname；<br>  g.启动应用</p>
<pre><code>adb shell am start -n 组件名
</code></pre><p>  h.测试<br>    monkey -v -p packname 点击数</p>
<p>  i.端口转发forward<br>    adb forward tcp:1100 tcp:1200</p>
<p>  j.重启手机<br>    adb reboot<br>  k.关机<br>    adb shell half<br>  l.重启到恢复模式<br>    adb reboot recovery<br>  m.重启引导模式<br>    adb reboot bootloader</p>
<p>linux 指令</p>
<p>1.ls 列出目下所有文件 -l 详细信息 *<br>2.df 查看磁盘空间<br>3.mount 产看磁盘信息<br>4.rm 删除文件  rm -r 删除文件夹<br>5.mount -o remountn rw /system 挂载/system为可读可写<br>6.mkdir 创建文件夹 创建多级文件 mkdir -p path<br>7.echo “11” &gt; /sdcard/a.txt;创建文件a.txt 并写入 “11”<br>8.cat path 查看文件内容；cat path1 &gt; path2 将 path1复制一份<br>9.cp path1 path2 复制文件<br>10.touch “filepath” 创建文件<br>11.chmod 777 filepath ;赋权<br>12.chown 0.0 filepath 赋所属用户及用户组<br>13.ps 看进程信息；<br>14.sleep 5；进程睡眠</p>
<p>root 下的操作</p>
<ol>
<li><p>卸载系统应用</p>
<p>  a.    pm path packanme 找到系统应用安装目录；<br>  b. rm apk_path;<br>  c.rm -r /data/data/packname<br>  d.pm uninstall packname</p>
</li>
</ol>
<ol>
<li><p>备份应用数据</p>
<p> a.备份apk<br> b.备份应用数据</p>
<pre><code>/data/data/packname
/sdcard/Android/data/packname
</code></pre></li>
</ol>
<pre><code>busybox cp -f -p -P -r /data/data/packname/* des_path;
</code></pre><p>3.字体更换<br>  替换/system/fonts/DroidSansFallback.ttf</p>
<p>4.开机动画</p>
<p>cat /sysytem/bin/bootanimation;中找路径<br>找到路径，替换，或删除，只留/system/media/bootanimation.zip</p>
<p>制作开机动画时需要注意，<br>用RAR压缩，压缩格式是.zip 存储方式。</p>
<p>5.截屏</p>
<p>scree sdk版本  图片保存路径.png</p>
<p>6.屏幕解锁</p>
<p>7.反编译<br>    a.apktool.bat d 要反编译的apk路径 反编译后的文件夹<br>    b.找到Mainfest.xml 找到主Activity ，替换google admob的key；<br>    c.apktool.bat b 要打包的文件夹 打包后apk的路径<br>    d.通过java环境下的 jarsigner -verbose -keystore E:\Epan\huluxia.key -signedjar C:\Users\xuhaiyang\Desktop\admo\sing_4096.apk C:\Users\xuhaiyang\Desktop\admo\un4096.apk huluxia<br>        命令签名；</p>
<p>com.ss.android.article.news</p>
<p>1.首先介绍下卓大师，各个功能。<br>2.有卓大师的功能展开课程的讲授。<br>3.首先讲讲root,root的概念，root后的作用,比较好玩的功能吸引学生：<br>   a.卸载系统应用。<br>   b.备份还原系统应用(聊天记录，游戏存档，联系人秒杀备份)。<br>    cp -r -f -P -p /data/data/packname/<em> /private/<br>    cp /sdcard/Android/data/packnamme/</em> /sdcard/</p>
<pre><code>-p     保留源文件或目录的属性，包括所有者、所属组、权限与时间
-P      保留源文件或目录的路径，此路径可以是绝对路径或相对路径，且目的目录必须已经存在
-f        强行复制文件或目录， 不论目的文件或目录是否已经存在
-r                  递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理
</code></pre><p>   c.冻结系统应用。<br>   d.屏幕图案锁忘了，实现屏幕解锁。<br>    /data/system/gesture.key<br>    adb_sh2(“chmod 777 /data/local/tmp/.sqlite3”);<br>/data/local/tmp/.sqlite3 /data/data/com.android.providers.settings/databases/settings.db \”update system set value=0 where name=’lock_pattern_autolock’;\”</p>
<p>name = “lockscreen.lockedoutpermanently”<br>lockscreen.password_salt<br>lock_pattern_autolock</p>
<p>rm /data/system/locksettings.db<br>rm /data/system/locksettings.db-wal<br>rm /data/system/locksettings.db-shm<br>   e.android系统更换字体，更换开机动画，开机第一屏的图片。<br>    recv = adb_sh2(“mv /sdcard/zds_font.ttf /system/fonts/DroidSansFallback.ttf”);<br>recv = adb_sh2(“chmod 644 /system/fonts/DroidSansFallback.ttf”);</p>
<p>4.列举两套root方案。a.2.3以下的Psneuter方案；b.4.0之上的bin4try;<br>5.讲讲刷机两套方案，一个针对htc的，包含官方解锁，root,刷机；另一个是大多数通用的方案。<br>6.备份和恢复整个android系统</p>
<p>0601</p>
<p>01JNI简介<br>什么是jni  (了解)<br>JNI java本地开发接口<br>JNI 是一个协议<br>这个协议用来沟通java代码和外部的本地代码(c/c++).<br>通过这个协议,java代码就可以调用外部的c/c++代码<br>外部的c/c++代码也可以调用java代码</p>
<p>为什么用jni(熟悉)<br>Java是交给虚拟机和底层交互,不直接和底层交互  跨平台啊<br>Java能开发驱动吗?<br>C代码开发驱动  </p>
<p>1.JNI扩展了java 虚拟机的能力, 驱动开发  (wifi-hotspot) 2.3 无线热点共享.<br>用C代码开发出来驱动,java代码调用C代码显示界面<br>医疗管理平台 红外线摄像头,摄像头驱动的开发,java-&gt; 驱动实现二维码扫描<br>2  C代码执行效率比java代码高 ,<br>原因1 java代码需要装载到虚拟机 ,C不需要<br>原因2 java代码自动回收内存,基于算法的回收(不可以控制)<br>  C代码手动回收内存,可以控制<br>3复用代码 (文件压缩,人脸识别opencv,7zip)<br>C语言 上世纪70年代产生<br>Java  95<br>复制粘贴  百分一1灵感+百分99的网上找代码<br>Opencv 人脸识别开源的函数库<br>7zip 压缩 解压缩的开源的函数库  360压缩 好压<br>Opencore  android采用的开源的媒体库 收音机开发<br>Ffmpeg 开源的媒体库   收音机的开发 万能播放器</p>
<p>4 特殊的业务场景<br> 系统定制  miui 百rom<br>  车载系统<br>  机顶盒<br>游戏  Cocos2d-x C++代码编写</p>
<p>怎么用jni(掌握)<br>1 熟练掌握java语言  (完成)<br>2.了解C/C++语言    (待完成)<br>3.掌握java jni流程    (第二天)<br>4.NDK (native develop kits )  </p>
<p>Sdk<br>Standard develop kits  标准的开发工具</p>
<p>了解jni  熟悉jni  掌握jni  精通jni</p>
<p>02 C语言入门<br>C -&gt; C++ -&gt;java-&gt;C#<br>          C+++  C++++</p>
<p>开发工具<br>dev-c++<br>原因 1体积小<br>原因2  C99的标准  </p>
<p>\n  换行符</p>
<p>编译的过程<br>连接的过程  运行</p>
<p>编译 ctrl+f9<br>运行 ctrl+f10</p>
<p>system(“pause”);  // 调用系统指令</p>
<p>Eclipse 也是用c代码开启的一个java代码<br>如果Eclipse不同正常开启,尝试下删除Eclipse.ini 配置文件</p>
<p>系统环境变量 前面有一个点 代表当前目录下<br>.;%JAVA_HOME%lib;%JAVA_HOME%lib\tools.jar</p>
<p>.exe格式的文件  windows可执行的二进制文件</p>
<p>03 C语言的基本数据类型<br> Java的基本数据类型</p>
<p>byte  short  char  int  long   float  double  boolean<br>  1    2     2    4   8      4     8        1</p>
<p>C语言基本数据类型<br>char, int, float, double,  long, short void   signed, unsigned,</p>
<p>CharSequence 就是字符序列</p>
<p>sizeof() 算出类型长度  </p>
<p>c语言中 int  float double  short  所占内存的长度和java语言中对应的类型一样<br>c语言中 char类型占1个字节  java中占两个字节<br>c 语言中 long类型占4个字节    java中占8个字节<br>c99标准下 long类型和int类型所占内存长度一样可以互相替换   C标准规范 规定long类型不能比int短</p>
<p>c99的标准 缺少byte类型   java中的byte 1字节  就可以用c语言中char类型替代java中byte</p>
<p>c99没有boolean    非0代表为true  0代表false<br>while(1){</p>
<p>}<br>相当于java语言while(true)</p>
<p>java中String不是基本数据类型   c语言表示String  字符数组 字符序列</p>
<p> 不影响本身类型的长度 但是影响int表示数的范围<br> signed,   有符号   修饰基本类型的类型<br> unsigned, 无符号</p>
<p>04输入输出函数<br>输出函数<br>System.out.println</p>
<p>%d  -  int<br>%ld – long int<br>%c  - char<br>%f -  float<br>%u – 无符号数<br>%hd – 短整型   half d<br>%lf – double    long f<br>%x – 十六进制输出 int 或者long int 或者short int<br>%o -  八进制输出<br>%s – 字符串</p>
<p>float double 类型 默认保留6位小数  四舍五入  </p>
<p>避免问题<br>输出的类型 一定要和占位符对应<br>char 类型如果按照整形输出打印ANSII</p>
<p>//          0110 0001 0000 1100<br>//1011 1100 0110 0001 0000 1100<br>// 如果int类型 以%hd输出 默认只输出数字的后16位</p>
<p>float double 类型  分为三段内存 整数部分 小数点 小数部分 表示方式和整数不太一样,<br>如果按照%d输出 这个数字不能预估<br>输入函数</p>
<p>#include <stdio.h>   </stdio.h></p>
<p>#include <stdlib.h><br>main(){<br>       // 原理 读取一个数 放到一个内存中<br>       // scanf<br>       int i;<br>       // 读取了一个整数 放到了i的内存空间中<br>       scanf(“%d”,&amp;i);  // &amp;取地址</stdlib.h></p>
<pre><code>printf(&quot;i的值为%d\n&quot;,i);


// 录入一个字符串
// c99的标准 中括号必须在变量后面
char c[] ={&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;} ;// 定义了字符数组 必须有初始值
scanf(&quot;%s&quot;,c);  // 字符数组名本身就是内存地址   %s 不要加ln
printf(&quot;录入的字符串为%s\n&quot;,c);


system(&quot;pause&quot;);   //让程序暂停   方便程序观察  
</code></pre><p>}<br>05指针 **<br>指针入门<br>指针就是内存地址 ,  地址就是内存的编号<br>32位操作系统只能表示4G内存</p>
<p>指针 == 地址<br>指针变量  存放地址的变量</p>
<p>但是要注意： 通常我们叙述时会把指针变量简称为指针，实际它们含义并不一样</p>
<p>指针深入<br>外挂  修改内存地址<br>墙 1010120310  00000000</p>
<p>Cheat Engine  欺骗引擎 通过指针修改程序的值  类似金山游侠</p>
<p><em>号的含义<br>1 ,乘法<br>3</em>4 =12;//   乘法<br>2 定义类型后面  定义指针变量类型<br>Int<em><br> 3 定义在指针变量前  例如</em>p<br>表示该指针变量 存放的地址 该地址对应的值</p>
<p>案例  交换两个数<br>值传递  不能交换两个数</p>
<p>void swap(int i,int j){  // 值传递<br>       int temp=i;<br>       i=j;<br>       j=temp;      </p>
<p>}<br>引用传递   可以交换两个数<br>把主函数变量的地址传递给子函数<br>子函数拿到主函数的地址 直接* 修改主函数的值  </p>
<p>void swap2(int<em> i,int</em> j){  //引动传递<br>       int temp=<em>i;
        </em>i=<em>j;
        </em>j=temp;</p>
<p>}</p>
<p>返回多个值<br>如果子函数想修改主函数里的值  必须把主函数变量的地址传递子函数</p>
<p>多级指针<br>适合吹牛</p>
<p> printf(“I的值为%d\n”,<em>**</em>t);</p>
<p>指针常见错误<br>1 野指针异常</p>
<p>2 指针类型和地址不匹配  </p>
<p>06 指针和数组的关系<br>数组<br>       // 数组是一块连续的内存空间<br>       // 同一类型的集合<br>       // 数组名和第一个元素的地址一致  </p>
<p>缓冲区越界补丁  微软工程师写数组的时候没有检查长度<br>数组一定要限制长度   </p>
<p>指针为什么这么智能<br>指针无论是什么类型 长度一致 都是4<br>在32位的系统+32位的编译器 长度都是4<br>指针就是为了存储地址 32位足够,<br>由于指针的长度都一致 为什么还定义不同类型指针<br>就是为了保持指针偏移量不一样<br>Int  偏移4个字节  short 偏移2个字节</p>
<p>指针的运算</p>
<pre><code>// 指针只有在连续的内存空间中 运算才有意义
// 数组中连续的内存空间
</code></pre><p>07 内存<br>Java的内存分配</p>
<p>栈和队列的区别<br>1 栈  先进后出   吃完吐<br>2 队列 先进先出  吃完啦</p>
<p>C语言的内存分配</p>
<p>静态分配内存<br>栈内存开辟的空间<br>   系统自动分配,系统自动回收</p>
<p>动态分配内存<br>堆内存中开辟的空间<br>程序员手动申请内存,手动回收<br>malloc()  memory alloc   // 类似于java new<br>free()  释放内存<br>自己申请自己释放</p>
<p>动态分配内存的灵活性<br>realloc 参数1 为之前申请内存地址  参数2 重新申请空间大小 返回值首地址<br>array=realloc(array,sizeof(int)*(len+lenadd)) ;  // 重新申请了内存空间 比以前大了</p>
<p>#include <stdio.h>   </stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <malloc.h><br>printArr(int<em> array,int len){<br>     int i=0;<br>     for(;i&lt;len;i++){<br>         // 指针比较智能 +i不是地址的增加 而是指针的偏移量,根据数组的类型的不同,偏移量不一样<br>        printf(“array[%d]=%d\n”,i,</em>(array+i));<br>     }      </malloc.h></p>
<p>}<br>main(){<br>       int len;<br>       printf(“请您输入数组的长度”);<br>       scanf(“%d”,&amp;len);<br>       int <em> array=malloc(sizeof(int)</em>len);  // 动态申请长度为len的数组的内存大小 返回值数组的首地址<br>       int i;<br>       for(i=0;i&lt;len;i++){<br>          printf(“请输入第%d个元素的值\n”,i);<br>          scanf(“%d”,array+i);<br>       }<br>        printArr(array,len);</p>
<pre><code>// 能大能小  
 // realloc 重新分配内存
 int lenadd;
 printf(&quot;请输入数组延长的长度&quot;);
  scanf(&quot;%d&quot;,&amp;lenadd);
 array=realloc(array,sizeof(int)*(len+lenadd)) ;  // 重新申请了内存空间 比以前大了
 for(i=len;i&lt;len+lenadd;i++){
         // 给新分配的内存地址赋值  
   printf(&quot;请输入第%d个元素的值\n&quot;,i);    
   scanf(&quot;%d&quot;,array+i);                          
 }
 printArr(array,len+lenadd);

 system(&quot;pause&quot;);   //让程序暂停   方便程序观察  
</code></pre><p>}</p>
<p>08 杂项<br>函数的指针<br>外挂 ,人 自动的打怪    打怪函数 函数指针</p>
<p>结构体<br>Class Student{<br>int age;<br>String name;<br>int id;</p>
<p>}</p>
<p>用来封装对象</p>
<p>结构体的长度就是里面各个元素的长度之和 (优化的原则,不足4个字节的按照4个字节处理 )</p>
<p>(<em>(</em>env)).asdf                *evn-&gt;newStringUTF(“hello”);</p>
<p>Union  联合体</p>
<p>枚举</p>
<p>#include <stdio.h></stdio.h></p>
<p>enum WeekDay<br>{<br>Monday=0,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday<br>};</p>
<p>int main(void)<br>{<br>  //int day;<br>  enum WeekDay day = Sunday;<br>  printf(“%d\n”,day); // 14<br>  system(“pause”);<br>  return 0;<br>}</p>
<p> typedef<br>给已知起别名<br>typedef int I;  // 给int类型起小名 I  </p>
<p>#define PI 3.14;  // 宏定义, 简单的替换 把3.14 替换PI  不做任何检查</p>
<p>0602</p>
<p>01JNI简介<br>什么是jni  (了解)<br>JNI java本地开发接口<br>JNI 是一个协议<br>这个协议用来沟通java代码和外部的本地代码(c/c++).<br>通过这个协议,java代码就可以调用外部的c/c++代码<br>外部的c/c++代码也可以调用java代码</p>
<p>为什么用jni(熟悉)<br>Java是交给虚拟机和底层交互,不直接和底层交互  跨平台啊<br>Java能开发驱动吗?<br>C代码开发驱动  </p>
<p>1.JNI扩展了java 虚拟机的能力, 驱动开发  (wifi-hotspot) 2.3 无线热点共享.<br>用C代码开发出来驱动,java代码调用C代码显示界面<br>医疗管理平台 红外线摄像头,摄像头驱动的开发,java-&gt; 驱动实现二维码扫描<br>2  C代码执行效率比java代码高 ,<br>原因1 java代码需要装载到虚拟机 ,C不需要<br>原因2 java代码自动回收内存,基于算法的回收(不可以控制)<br>  C代码手动回收内存,可以控制<br>3复用代码 (文件压缩,人脸识别opencv,7zip)<br>C语言 上世纪70年代产生<br>Java  95<br>复制粘贴  百分一1灵感+百分99的网上找代码<br>Opencv 人脸识别开源的函数库<br>7zip 压缩 解压缩的开源的函数库  360压缩 好压<br>Opencore  android采用的开源的媒体库 收音机开发<br>Ffmpeg 开源的媒体库   收音机的开发 万能播放器</p>
<p>4 特殊的业务场景<br> 系统定制  miui 百rom<br>  车载系统<br>  机顶盒<br>游戏  Cocos2d-x C++代码编写</p>
<p>怎么用jni(掌握)<br>1 熟练掌握java语言  (完成)<br>2.了解C/C++语言    (待完成)<br>3.掌握java jni流程    (第二天)<br>4.NDK (native develop kits )  </p>
<p>Sdk<br>Standard develop kits  标准的开发工具</p>
<p>了解jni  熟悉jni  掌握jni  精通jni</p>
<p>02 C语言入门<br>C -&gt; C++ -&gt;java-&gt;C#<br>          C+++  C++++</p>
<p>开发工具<br>dev-c++<br>原因 1体积小<br>原因2  C99的标准  </p>
<p>\n  换行符</p>
<p>编译的过程<br>连接的过程  运行</p>
<p>编译 ctrl+f9<br>运行 ctrl+f10</p>
<p>system(“pause”);  // 调用系统指令</p>
<p>Eclipse 也是用c代码开启的一个java代码<br>如果Eclipse不同正常开启,尝试下删除Eclipse.ini 配置文件</p>
<p>系统环境变量 前面有一个点 代表当前目录下<br>.;%JAVA_HOME%lib;%JAVA_HOME%lib\tools.jar</p>
<p>.exe格式的文件  windows可执行的二进制文件</p>
<p>03 C语言的基本数据类型<br> Java的基本数据类型</p>
<p>byte  short  char  int  long   float  double  boolean<br>  1    2     2    4   8      4     8        1</p>
<p>C语言基本数据类型<br>char, int, float, double,  long, short void   signed, unsigned,</p>
<p>CharSequence 就是字符序列</p>
<p>sizeof() 算出类型长度  </p>
<p>c语言中 int  float double  short  所占内存的长度和java语言中对应的类型一样<br>c语言中 char类型占1个字节  java中占两个字节<br>c 语言中 long类型占4个字节    java中占8个字节<br>c99标准下 long类型和int类型所占内存长度一样可以互相替换   C标准规范 规定long类型不能比int短</p>
<p>c99的标准 缺少byte类型   java中的byte 1字节  就可以用c语言中char类型替代java中byte</p>
<p>c99没有boolean    非0代表为true  0代表false<br>while(1){</p>
<p>}<br>相当于java语言while(true)</p>
<p>java中String不是基本数据类型   c语言表示String  字符数组 字符序列</p>
<p> 不影响本身类型的长度 但是影响int表示数的范围<br> signed,   有符号   修饰基本类型的类型<br> unsigned, 无符号</p>
<p>04输入输出函数<br>输出函数<br>System.out.println</p>
<p>%d  -  int<br>%ld – long int<br>%c  - char<br>%f -  float<br>%u – 无符号数<br>%hd – 短整型   half d<br>%lf – double    long f<br>%x – 十六进制输出 int 或者long int 或者short int<br>%o -  八进制输出<br>%s – 字符串</p>
<p>float double 类型 默认保留6位小数  四舍五入  </p>
<p>避免问题<br>输出的类型 一定要和占位符对应<br>char 类型如果按照整形输出打印ANSII</p>
<p>//          0110 0001 0000 1100<br>//1011 1100 0110 0001 0000 1100<br>// 如果int类型 以%hd输出 默认只输出数字的后16位</p>
<p>float double 类型  分为三段内存 整数部分 小数点 小数部分 表示方式和整数不太一样,<br>如果按照%d输出 这个数字不能预估<br>输入函数</p>
<p>#include <stdio.h>   </stdio.h></p>
<p>#include <stdlib.h><br>main(){<br>       // 原理 读取一个数 放到一个内存中<br>       // scanf<br>       int i;<br>       // 读取了一个整数 放到了i的内存空间中<br>       scanf(“%d”,&amp;i);  // &amp;取地址</stdlib.h></p>
<pre><code>printf(&quot;i的值为%d\n&quot;,i);


// 录入一个字符串
// c99的标准 中括号必须在变量后面
char c[] ={&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;,&apos; &apos;} ;// 定义了字符数组 必须有初始值
scanf(&quot;%s&quot;,c);  // 字符数组名本身就是内存地址   %s 不要加ln
printf(&quot;录入的字符串为%s\n&quot;,c);


system(&quot;pause&quot;);   //让程序暂停   方便程序观察  
</code></pre><p>}<br>05指针 **<br>指针入门<br>指针就是内存地址 ,  地址就是内存的编号<br>32位操作系统只能表示4G内存</p>
<p>指针 == 地址<br>指针变量  存放地址的变量</p>
<p>但是要注意： 通常我们叙述时会把指针变量简称为指针，实际它们含义并不一样</p>
<p>指针深入<br>外挂  修改内存地址<br>墙 1010120310  00000000</p>
<p>Cheat Engine  欺骗引擎 通过指针修改程序的值  类似金山游侠</p>
<p><em>号的含义<br>1 ,乘法<br>3</em>4 =12;//   乘法<br>2 定义类型后面  定义指针变量类型<br>int<em><br> 3 定义在指针变量前  例如</em>p<br>表示该指针变量 存放的地址 该地址对应的值</p>
<p>案例  交换两个数<br>值传递  不能交换两个数</p>
<p>void swap(int i,int j){  // 值传递<br>       int temp=i;<br>       i=j;<br>       j=temp;      </p>
<p>}<br>引用传递   可以交换两个数<br>把主函数变量的地址传递给子函数<br>子函数拿到主函数的地址 直接* 修改主函数的值  </p>
<p>void swap2(int<em> i,int</em> j){  //引动传递<br>       int temp=<em>i;
        </em>i=<em>j;
        </em>j=temp;</p>
<p>}</p>
<p>返回多个值<br>如果子函数想修改主函数里的值  必须把主函数变量的地址传递子函数</p>
<p>多级指针<br>适合吹牛</p>
<p> printf(“I的值为%d\n”,<em>**</em>t);</p>
<p>指针常见错误<br>1 野指针异常</p>
<p>2 指针类型和地址不匹配  </p>
<p>06 指针和数组的关系<br>数组<br>       // 数组是一块连续的内存空间<br>       // 同一类型的集合<br>       // 数组名和第一个元素的地址一致  </p>
<p>缓冲区越界补丁  微软工程师写数组的时候没有检查长度<br>数组一定要限制长度   </p>
<p>指针为什么这么智能<br>指针无论是什么类型 长度一致 都是4<br>在32位的系统+32位的编译器 长度都是4<br>指针就是为了存储地址 32位足够,<br>由于指针的长度都一致 为什么还定义不同类型指针<br>就是为了保持指针偏移量不一样<br>Int  偏移4个字节  short 偏移2个字节</p>
<p>指针的运算</p>
<pre><code>// 指针只有在连续的内存空间中 运算才有意义
// 数组中连续的内存空间
</code></pre><p>07 内存<br>Java的内存分配</p>
<p>栈和队列的区别<br>1 栈  先进后出   吃完吐<br>2 队列 先进先出  吃完啦</p>
<p>C语言的内存分配</p>
<p>静态分配内存<br>栈内存开辟的空间<br>   系统自动分配,系统自动回收</p>
<p>动态分配内存<br>堆内存中开辟的空间<br>程序员手动申请内存,手动回收<br>malloc()  memory alloc   // 类似于java new<br>free()  释放内存<br>自己申请自己释放</p>
<p>动态分配内存的灵活性<br>realloc 参数1 为之前申请内存地址  参数2 重新申请空间大小 返回值首地址<br>array=realloc(array,sizeof(int)*(len+lenadd)) ;  // 重新申请了内存空间 比以前大了</p>
<p>#include <stdio.h>   </stdio.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <malloc.h><br>printArr(int<em> array,int len){<br>     int i=0;<br>     for(;i&lt;len;i++){<br>         // 指针比较智能 +i不是地址的增加 而是指针的偏移量,根据数组的类型的不同,偏移量不一样<br>        printf(“array[%d]=%d\n”,i,</em>(array+i));<br>     }      </malloc.h></p>
<p>}<br>main(){<br>       int len;<br>       printf(“请您输入数组的长度”);<br>       scanf(“%d”,&amp;len);<br>       int <em> array=malloc(sizeof(int)</em>len);  // 动态申请长度为len的数组的内存大小 返回值数组的首地址<br>       int i;<br>       for(i=0;i&lt;len;i++){<br>          printf(“请输入第%d个元素的值\n”,i);<br>          scanf(“%d”,array+i);<br>       }<br>        printArr(array,len);</p>
<pre><code>// 能大能小  
 // realloc 重新分配内存
 int lenadd;
 printf(&quot;请输入数组延长的长度&quot;);
  scanf(&quot;%d&quot;,&amp;lenadd);
 array=realloc(array,sizeof(int)*(len+lenadd)) ;  // 重新申请了内存空间 比以前大了
 for(i=len;i&lt;len+lenadd;i++){
         // 给新分配的内存地址赋值  
   printf(&quot;请输入第%d个元素的值\n&quot;,i);    
   scanf(&quot;%d&quot;,array+i);                          
 }
 printArr(array,len+lenadd);

 system(&quot;pause&quot;);   //让程序暂停   方便程序观察  
</code></pre><p>}</p>
<p>08 杂项<br>函数的指针<br>外挂 ,人 自动的打怪    打怪函数 函数指针</p>
<p>结构体<br>Class Student{<br>int age;<br>String name;<br>int id;</p>
<p>}</p>
<p>用来封装对象</p>
<p>结构体的长度就是里面各个元素的长度之和 (优化的原则,不足4个字节的按照4个字节处理 )</p>
<p>Union  联合体</p>
<p>枚举</p>
<p>#include <stdio.h></stdio.h></p>
<p>enum WeekDay<br>{<br>Monday=0,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday<br>};</p>
<p>int main(void)<br>{<br>  //int day;<br>  enum WeekDay day = Sunday;<br>  printf(“%d\n”,day); // 14<br>  system(“pause”);<br>  return 0;<br>}</p>
<p> typedef<br>给已知起别名<br>typedef int I;  // 给int类型起小名 I  </p>
<p>#define PI 3.14;  // 宏定义, 简单的替换 把3.14 替换PI  不做任何检查</p>
<p>09字符串<em>*<br>String str=”Hello”;// java中的String<br> char</em> str=”abc”;// &lt;=&gt; char str[]={‘a’,’b’,’c’,’\0’};</p>
<p>10 JNI的开发<br>Java 调用C代码  C代码回调java代码</p>
<p>1  以java为主导,  新的项目<br>命令C工程师  用C代码实现了功能<br>JNI 工程师   用胶水把java代码和C代码粘起来<br>(理想情况)</p>
<p>2  二次开发  C代码写好  打包函数库  .so<br>头文件   接口  超市的清单       编译器<br>函数库   实现类   超市的具体货物  连接</p>
<p>11 NDK<br> Native devoloper kits  本地开发工具包</p>
<p>为什么使用NDK?<br>1 windows下的可执行文件时 .exe<br>  Linux  下可执行文件   elf</p>
<p>2  windows下的函数库   .dll<br>  Linux 下的函数库    .so</p>
<p>开发平台   windows 开发<br>把windows平台开发下的C代码 打包成linux下的函数库    交叉编译<br>Ndk 提供交叉编译的工具链</p>
<p>Linux 开发需要NDK吗 ?<br>需要<br>X86 电脑CPU<br>Arm CPU<br>C代码不能跨平台  因为他直接和底层交互<br>不同CPU 执行的C代码不一样 ,所以如果再linux下开发的C代码 需要打包成ArmCPU 使用的函数                                                交叉编译</p>
<p>怎么使用NDK<br>1  下载NDK<br>2  解压到非中文目录</p>
<p>NDK 目录结构<br>Build  ndk搭建的环境<br>Docs    文档<br>Platforms  支持的平台<br>Arm  英国Arm  不生产CPU  研究专利  主流手机CPU 功耗低<br>Mips  授权 研究CPU专利    (龙芯, cos copy other system)<br>x86   inter     联想 K900   没有明显的优势</p>
<p>Samples   示例代码<br>Sources  ndk的源码<br>Tests  测试<br>Toolchains  交叉编译的工具链</p>
<p>ndk-build.cmd   交叉编译的指令</p>
<p>代表NDK 安装成功</p>
<p>面试相关<br>Ndk 7版本 虽然是windows版本的 但是不太支持windows开发<br>  Ndk最早都是linux版本<br>ndk-build 是linux操作系统的命令文件</p>
<p>之前在windows下开发 需要装一个linux系统的模拟器 Cygwin</p>
<p>12 JNI开发流程<br>Jni规范协议<br>C:\android-ndk-r9b-windows-x86\android-ndk-r9b\platforms\android-9\arch-arm\usr\include</p>
<p>Jni.h  java虚拟机的实现原理</p>
<p>Java中String  不是C语言中 char<em> 是void</em></p>
<p>处理返回值的  所有java方法返回值肯定是这几种类型之一</p>
<p>typedef const struct JNINativeInterface* JNIEnv;</p>
<p>JNINativeInterface  结构体 定义了java最基本的方法<br>JNIEnv 是该结构体的指针</p>
<p>Jni流程<br>步骤1<br>    // 1 声明本地方法 类似声明接口 以分号结尾没有大括号<br>    public native String helloFromC();<br>步骤2<br>在工程目录下 创建一个名字叫jni的文件夹<br>步骤3<br>在jni目录下创建C代码  引入头文件 <jni.h><br>严格按照规范 找到对应的java方法</jni.h></p>
<p>返回值   Java<em> 全类名(</em>间隔) _ 方法名 (JNIEnv* env,jobject obj)</p>
<p>写C代码<br>// char* 不是java中 String</p>
<p>步骤4<br>创建Android.mk脚本文件</p>
<p>把C代码编译成手机可以用函数库  交叉编译<br>Android NDK: Your APP_BUILD_SCRIPT points to an unknown file: ./jni/Android.mk<br>进入工程目录下 执行ndk-build 命令</p>
<p>.o   c语言中编译的中间文件  类似java .class<br>.o.d 对中间文件进一步优化</p>
<p>Libs 目录<br>armeabi    arme  abi  appliction binarry interface<br>里面生成ArmCpu可用的二级制文件<br>步骤5<br>Java代码加载函数库<br>System.loadLibrary(“hello-jni”); // 去掉前面的lib 去掉后面.so</p>
<p>步骤6<br>在java代码 直接调用本地方法  当做普通方法调用</p>
<p>Javah 命令</p>
<p>注意 如果java方法本身带<em>  C方法应该在</em>后面+1</p>
<p>如果include 引入是我们自定义的头文件  用””<br>引入系统提供 用&lt;&gt;</p>
<p>jdk 6.0 在Android工程的bin\classes目录下执行javah 包名+类名<br>C:\workspace\JNIDemo\bin\classes&gt;Javah com.ithm.jnidemo.MainActivity<br>jdk 7.0 在Android 工程的src目录下执行javah 包名+类名</p>
<p>Jni开发常见的错误<br>错误1    java代码找不到对应的C实现<br>04-29 03:14:25.036: E/AndroidRuntime(3046): Caused by: java.lang.UnsatisfiedLinkError: Native method not found: com.ithm.jnidemo.MainActivity.helloFromC:()Ljava/lang/String;<br>原因 1 C方法没有按照规范写<br>原因 2 引入的函数库名字错误 或者没有引入函数库<br>原因 3  运行在了一个不支持的平台上</p>
<p>错误2  没有写Android.mk文件<br>Android NDK: Your APP_BUILD_SCRIPT points to an unknown file: ./jni/Android.mk</p>
<p>C:/android-ndk-r9b-windows-x86/android-ndk-r9b/build/core/add-application.mk:171<br>: <strong><em> Android NDK: Aborting…    .  Stop.<br>错误3  Android.mk 没有写<br>C:/android-ndk-r9b-windows-x86/android-ndk-r9b/build/core/build-all.mk:89: Andro<br>id NDK: WARNING: There are no modules to build in this project!<br>错误4   引入中文全角 空格或者回车<br>jni/Android.mk:3: </em></strong> missing separator.  Stop.<br>错误5<br>如果交叉编译的时候 直接报错了 证明C代码可能有编译时异常 按照日志检查<br>错误6  c语言中有运行时异常<br>04-29 03:51:11.516: A/libc(7337): Fatal signal 11 (SIGSEGV) at 0x476a41a5 (code=2), thread 7337 (om.ithm.jnidemo)</p>
<p>Android.mk文件</p>
<p>跨平台运行<br>如果想跨平台 需要在jni目录下 创建Application.mk文件<br>APP_ABI := armeabi armeabi-v7a x86 mips</p>
<p>根据不同CPU生成不同的函数库<br>缺点  APK体积变大了<br>根据你的需求 去定制不同平台函数库<br>简单的开发流程<br>1 配置NDK  (配置一次)<br>Windows-&gt; Properfecences-&gt; Android-&gt; NDK</p>
<p>2 右键点击工程目录</p>
<p>3 把CPP代码改成 C代码 (非必须的)<br>4 在java代码中定义native方法  通过javah命令生成方法的签名文件</p>
<p>5 如果你想要有代码提示<br>  右键点击工程  Properties</p>
<p>6 交叉编译<br>切换到C/C++视图  点击上面锤子 交叉编译了</p>
<p>7 java 代码引入函数库<br>8 直接调用本地方法</p>
<p>9 避免警告<br>    只需要在你的工程的：<br>    Application.mk<br>    文件中添加如下代码即可：<br>    APP_PLATFORM := android-8  </p>
<p>13 java和C语言的数据传递<br>Java传递数据给C语言<br>Kiss  keep it simple and stupid  java传递数据给C语言的原则</p>
<p>C语言中输出log<br>首先在C代码中</p>
<p>#include <android log.h=""></android></p>
<p>#define LOG_TAG “System.out”</p>
<p>#define LOGD(…) <strong>android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, </strong>VA_ARGS__)</p>
<p>#define LOGI(…) <strong>android_log_print(ANDROID_LOG_INFO, LOG_TAG, </strong>VA_ARGS__)</p>
<p>Android.mk 文件中增加<br>LOCAL_LDLIBS += -llog</p>
<p>C语言如何回调java方法<br>游戏开发中   通过C语言调用java显示界面的方法<br>Java开发好的代码   C语言复用java代码</p>
<p>按照反射步骤回调java代码</p>
<p>Javap  指令   需要来到工程bin/classes目录</p>
<p>JNIEnv * env,   虚拟机环境变量的指针</p>
<p>jobject obj   java的对象/ native方法所在类的对象</p>
<p>如果native方法和要调用的方法不在同一个类中 需要在C代码中创建调用方法所在类的对象</p>
<p> Jstring2CStr 工具方法也是用到了 C语言回调java代码</p>
<p>C语言回调java的静态方法<br>1 通过 找到static方法<br> jmethodID   (<em>GetStaticMethodID)(JNIEnv</em>, jclass, const char<em>, const char</em>);</p>
<p>2 调用静态方法<br>callStaticVoidMethod();  //静态无返回值</p>
<p>应用场景</p>
<p>中文乱码问题<br>把C文件修改成 UTF-8的编码就OK<br> Ndk r6 的时候 需要改成iso-8859-1</p>
<p>环境变量的问题<br>.;%JAVA_HOME%lib;%JAVA_HOME%lib\tools.jar</p>
<p>14 C++ 语言</p>
<p>对C语言进行了包装</p>
<p>_JNIEnv    就是JNIEnv</p>
<p>_JNIEnv C++就是结构体  C是JNINativeInterface指针</p>
<p>(*env)-&gt; c代码的写法<br>env-&gt;  cpp的写法</p>
<p>好处1  代码简单<br>好处2  编译时异常 Eclipse 提醒了<br>好处3  不用的形参可以不用起名字</p>
<p>Ndk-build clean</p>
<p>15 怎么窃取<br>本代码只做教学使用  如有侵权 敬请见谅</p>
<p> 像素点 1个int 表示    ARGB   255 255  255  255</p>
<p>1 反编译别人的代码<br>2 拿到函数库<br>3 复制native方法  注意包名和类名不要换<br>4 直接调用方法</p>
<p>16 真实案例<br>所有传感器都是基于电流<br>电流的不同 产生不同的电压<br>不同电压产生不同的C代码<br>Java代码调用不同C代码  显示不同的界面</p>
<p>rand() 返回随机数  伪随机基于算法<br>RAND_MAX    0x7FFF 随机数的最大值  </p>
<p>自定义控件<br>所有的控件都是继承View</p>
<p>所有控件都是画到屏幕上的<br>onDraw 告诉控件怎么画</p>
<p>定时器 获取压力值</p>
<p>17 监听应用卸载<br>数据分析,<br>Android手机  提示框 提示用户有APK需要更新  </p>
<p>用户反馈意见</p>
<p>问题 1 如何监听程序卸载<br>广播接受者<br>电话到来  短信   电量变化  锁屏</p>
<p>监听自己卸载    卸载完了 广播接受者已经over</p>
<p>开子线程<br>遍历 data/data/包名  这个文件夹没了 证明卸载<br>应用都没有 子线程给着陪葬了<br>主进程退出 ,里面线程都没了  </p>
<p>开启一个别进程<br>去遍历 data/data/包名   这个文件夹没了 证明卸载</p>
<p>问题2 如何开启多个进程<br>Service    本地服务     远程服务(多个进程)</p>
<p>JNI  C代码开启一个C进程<br>去遍历 data/data/包名</p>
<p>fork() 函数    开启一个子进程</p>
<p>问题3 如何去遍历文件夹<br>    while(flag){  // 耗电<br>    FILE*file=fopen(“/data/data/com.example.uninstall”,”r”);<br>            if(file==NULL){ //null<br>                // 应用程序被卸载了<br>                LOGI(“uninstall”);<br>                flag=0;<br>            }<br>            sleep(1); //睡1秒<br>        }</p>
<p>面试问题<br>     能不能开启多个进程 可以    </p>
<p>问题4 如何在C代码中打开浏览器<br>调用linux 指令 打开浏览器<br>am  acitivty manager</p>
<p>am start -a android.intent.action.VIEW -d <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>  //打开浏览器<br>// 第一个参数 从path目录找到am ,第二个参数执行am   最后1个参数空字符 代表指令结束<br>execlp(“am”,”am”,”start”,”-a”,”android.intent.action.VIEW”,”-d”,”<a href="http://www.baidu.com&quot;,(char*)NULL" target="_blank" rel="external">http://www.baidu.com&quot;,(char*)NULL</a>);</p>
<p>0701</p>
<p>View的绘制流程.<br>    measure        -&gt;      layout        -&gt;      draw<br>    测量                 排版                绘制<br>      |                      |                      |<br>   onMeasure            onLayout            onDraw        // android系统提供给开发者来在某个时间段做相应处理的回调方法</p>
<p>滑动开关:</p>
<ol>
<li>实现onMeasure方法设置滑动开关的宽度和高度.</li>
<li>绘制当前滑动开关.<br> 2.1. 绘制背景<br> 2.2. 绘制滑动块.</li>
</ol>
<p>想改变控件的状态必须重绘. 必须得调用onDraw.<br>invalidate(); 此方法是用于刷新控件时调用. 会重绘当前控件.</p>
<p>自定义属性:</p>
<ol>
<li><p>在values目录下创建一个文件attrs.xml. 在里边声明属性<br> 例:</p>
<pre><code>&lt;declare-styleable name=&quot;ToggleView&quot;&gt;
    &lt;attr name=&quot;switchBackground&quot; format=&quot;reference&quot; /&gt;
    &lt;attr name=&quot;slideButtonBackground&quot; format=&quot;reference&quot; /&gt;
    &lt;attr name=&quot;toggleState&quot; format=&quot;boolean&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre></li>
<li><p>在布局文件中引用自定义的属性.<br> 2.1. 在布局文件的根节点中声明命名空间.</p>
<pre><code>xmlns:itheima=&quot;http://schemas.android.com/apk/res/com.itheima29.toggleview&quot;
</code></pre><p> 2.2. 在自定义控件中引用自定义属性.</p>
<pre><code>itheima:slideButtonBackground=&quot;@drawable/slide_button_background&quot;
itheima:switchBackground=&quot;@drawable/switch_background&quot;
itheima:toggleState=&quot;false&quot;
</code></pre></li>
<li><p>在控件中java代码中把xml布局中使用的自定义属性的值取出来.<br> 3.1. 把属性集合(AttributeSet)中所有属于自定义属性(ToggleView)的取出来</p>
<pre><code>TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.ToggleView);
</code></pre><p> 3.2. 循环遍历取自定义属性的值.</p>
<pre><code>for (int i = 0; i &lt; ta.getIndexCount(); i++) {
    int index = ta.getIndex(i);     // 获取第i个属性的在自定义属性数组中的索引

    switch (index) {
    case R.styleable.ToggleView_slideButtonBackground:         // 当前是滑动块的背景
        int slideButtonBackgroundID = ta.getResourceId(index, -1);
        setSlideButtonBackgroundID(slideButtonBackgroundID);
        break;
    case R.styleable.ToggleView_switchBackground:         // 当前是滑动开关背景的属性
        int switchBackgroundID = ta.getResourceId(index, -1);
        setSwitchBackgroundID(switchBackgroundID);
        break;
    case R.styleable.ToggleView_toggleState:         // 当前是开关的状态属性
        toggleState = ta.getBoolean(index, false);
        break;
    default:
        break;
    }
}
</code></pre></li>
</ol>
<p>9.png图片.<br> 左边和上边  定义当前图片怎样去拉伸. 拉伸时, 一般只点直线的地方<br> 右边和下边  定义当前图片显示内容的区域.</p>
<p>0702</p>
<p>measure        -&gt;        layout        -&gt;        draw<br>    |<br>onMeasure</p>
<ol>
<li><p>在onMeasure测量宽高时, 测量子控件(菜单, 主界面)的宽和高.</p>
</li>
<li><p>在layout布置布局时, 把菜单和主界面放到指定的位置上.</p>
</li>
</ol>
<p>滑动业务处理:</p>
<ol>
<li><p>按下, 用成员变量记录x轴的偏移量: x轴最后一次的偏移量 40</p>
</li>
<li><p>移动: 移动后最新的x轴偏移量 50, x轴最后一次的偏移量 45<br> 1). 增量值 = x轴最后一次的偏移量 - 移动后最新的x轴偏移量;</p>
<pre><code>-5 = 40 - 45;
-5 = 45 - 50;
</code></pre><p> 2). 根据增量值, 使用scrollBy进行滑动.</p>
<pre><code>scrollBy(增量值, 0);
scrollBy(-5, 0);
scrollBy(-5, 0);
</code></pre><p> 3). x轴最后一次的偏移量 = 移动后最新的x轴偏移量;</p>
<pre><code>x轴最后一次的偏移量 = 45;
x轴最后一次的偏移量 = 50;
</code></pre></li>
<li><p>抬起<br> 判断当前x轴的偏移量是否超过了-120(菜单界面的宽度一般的负数)</p>
<p> x轴偏移量 &gt; -120   回到主界面<br> x轴偏移量 &lt; -120   回到菜单界面</p>
</li>
</ol>
<p>startScroll(startX, startY, dx, dy, duration)<br>-80  -&gt;  0<br>startX 开始模拟的位置  -80<br>dx 0 - (-80) = 80;    根据开始位置模拟数据的增量值<br>duration 模拟这些数据所需要的时间</p>
<p>——————————-团队开发须知—————————–<br>0、开发环境<br>            统一开发环境,myeclipse8.5,adt,运行测试android4.2，避免意想不到的问题</p>
<p>一、例会制度:<br>每天早上一个会:讨论昨天完成情况,今天任务.方向,包括业务逻辑的讨论<br>每天晚上一个会:讨论今天遇到的问题,或没解决的问题,或业务问题或生活问题等</p>
<p>二、注释及命名规范:<br>1.所有命名要遵循驼峰式<br>2.控件名称命名规范<br>3.注释规范:<br>    ①类要加注释,并且注明作者.时间<br>    ②所有方法和属性要加注释,特别是接口和抽象类中的方法和属性<br>    ③业务逻辑注释（可模仿老师，先把架子搭起来，写上注释，然后在写代码，这样思路比较清晰）<br>4.不允许出现中文命名,不知道问有道(我们是有经验的开发人员)</p>
<p>三、SVN操作规范:<br>①一个小模块写完,必须测试通过,(如果无法测试的功能,应确保无误) 再提交,<br>    提交时注意:–在群里发个消息(完成什么模块或功能,现在提交代码)<br>            这样可以减少冲突<br>         –先与资源库同步,看当前资源库的状态，再进行相应操作<br>②解决复杂冲突时,应与对方面对面沟通,(很重要)，会减少很多麻烦<br>③提交代码时,bin、gen文件不需要提交（ignore）<br>④不要随意操作SVN中文件</p>
<p>四、笔记规范:<br>项目下有个doc文件夹,每个组员必须每天做好笔记,内容包括:<br>    ①昨天任务完成情况<br>    ②没有解决的问题<br>    ③今天任务<br>    ④记录当天所做的功能，以及遇到的问题</p>
<p>五、其他<br>    ①多沟通<br>    ②当修改别人的代码的时候一定要飞Q一下，以减少冲突<br>    ③团队气氛调动<br>    ④类名注释<br>    Window-&gt;preferences-&gt;java-&gt;code style -&gt;code templates -&gt;Comments -&gt;typese-&gt;edit-&gt;<br>        /**</p>
<pre><code>     * @Description ${todo}
     * @author Andy
     * @date ${date} ${time}
     * ${tags}
     */
⑤统一编码UTF-8

PM:（技术上不一定是组内最牛的，但需要协调好组内气氛）
</code></pre><p>①团结所有组员，不能自己单干<br>②针对每天讲课内容进行总结，确保项目组每位成员都已经接收<br>③及时了解组员存在问题，避免人员流失（出工不出力）<br>④分工<br>⑤监管项目进度</p>
<p>TL：（技术上过硬）<br>①与PM配合完成工作<br>②组内技术难题攻关</p>
<p>PG：（模块功能的实现）<br>①配合好PM和TL的工作，做好自己的模块内容</p>
<p>基础好的<br>①负责项目主线模块工作<br>②帮助身边基础弱的同学<br>③留意PM和TL的工作，积极参与到项目的管理中</p>
<p>基础弱的<br>①完成项目中较简单模块<br>②积极学习，尽快将基础夯实<br>③坚持</p>
<p>通过这个项目，希望大家融入到团队开发中，找到自身的不足，利用后面的时间逐渐完善自己。</p>
<p>注意事项：<br>①建立例会制度，如每天课后5:30<br>a、针对每天讲课内容进行总结，确保项目组每位成员都已经接收<br>b、解决项目组存在问题：如统一编码(UTF-8)、统一开发环境、统一最低兼容版本等<br>c、风险规避（人员）<br>②每组PM指定一个(两个)TL，协助组织工作(项目的主要矛盾和次要矛盾)<br>③要充分相信自己的组员<br>④项目组成员之间的沟通<br>a、在项目开发过程中，同组人员除了在传输文件的时候可以使用聊天工具，其他情况下禁止使用，有什么问题直接沟通。<br>⑤小技巧<br>a、TODO的使用<br>b、内容提交到SVN时不需要提交bin、R文件和测试文件信息<br>⑥小组内可以使用用WIFI局域网，利用真机进行测试</p>
<p>常见问题:<br>a、导入工程常见问题：<br>①Build path<br>②Java compiler<br>③Android–project build target<br>b、ids.xml文件</p>
<p>1002</p>
<p>1  屏幕适配<br>2  加载图片更多 ，避免oom异常<br>3  listview的优化</p>
<p>通用的模块<br>1 项目的结构来说。</p>
<p>   a 底部导航栏 + 内容页； eg ：新浪微博</p>
<p>   b 侧滑菜单 + viewpager  eg ：网易新闻</p>
<p>   c 侧滑菜单 +底部导航栏　eg ：360手机助手</p>
<p>２　主页展现形式<br>　　　<br>　　listview + 轮播图   </p>
<pre><code>详情页
</code></pre><p>3   通用的模块</p>
<pre><code>a 消息推送
b 二维码扫描
c 下拉刷新 + 滚动加载
d json解析
e 分享
f 联网引擎
g 语音识别 + 语音播报
h 即时聊天 （简易版本）
i 避免oom异常
</code></pre><p>  a  欢迎页面</p>
<pre><code>1  读取io流
2  浏览器下载
3  downloadManager
</code></pre><p>   b  更多（设置）         </p>
<p>viewpager ：预加载 默认加载 下一页</p>
<p>保存状态：</p>
<p>系统部 ：应用<br>    产品<br>    美工<br>    设计<br>    制作<br>1 UI 效果图</p>
<p>  美工：<br>  制作：  480 * 800 (当我在做欢迎界面的时候，就需要在切一张1280　×　７２０)　，<br>  　　　　　　　　　（如果在做新手指引界面的时候，需要切１２８０　×　７２０）</p>
<p>  hdpi ： 480 * 800  </p>
<p>  mdpi ：320*480</p>
<p>  xhdpi：1280 *720</p>
<p>2 接口文档</p>
<p>3 原型图</p>
<p> 屏幕密度</p>
<p>ldpi    Resources for low-density (ldpi) screens (~120dpi).<br>mdpi    Resources for medium-density (mdpi) screens (~160dpi). (This is the baseline density.)<br>hdpi    Resources for high-density (hdpi) screens (~240dpi).<br>xhdpi    Resources for extra high-density (xhdpi) screens (~320dpi).</p>
<p>icon的图片的大小</p>
<p>36x36 for low-density<br>48x48 for medium-density<br>72x72 for high-density<br>96x96 for extra high-density</p>
<p>缩放因子</p>
<p>3:4:6:8</p>
<p>屏幕的比例<br>ldpi　　　　０.７５<br>mdpi　　　　１<br>hdpi　　　　１.５<br>xhdpi　　　　２.０</p>
<p>屏幕的基本概念</p>
<p>屏幕的大小： 4.0英寸,5.0英寸 ，物理屏幕，手机的对角线。<br>分辨率：     1280 *720 ，屏幕像素点的总和。跟屏幕适配没有任何关系。<br>密度  ：     dpi每英寸点数（dots per inch） ，跟适配有关。</p>
<p>锻炼大家能力（程序员）<br>1 学习能力<br>  a  需要别人代码（源码）<br>  b  学习新技术的能力<br>2 提高大家解决的bug的能力  </p>
<p>initView();<br>initData();</p>
<p>1  什么library？</p>
<p>   library 就是jar包，（sdk）；</p>
<p>2  为什么使用library ，而不直接使用jar。   </p>
<p>错误信息：</p>
<p>[2014-05-24 15:54:24 - 智慧北京] Found 2 versions of android-support-v4.jar in the dependency list,<br>[2014-05-24 15:54:24 - 智慧北京] but not all the versions are identical (check is based on SHA-1 only at this time).<br>[2014-05-24 15:54:24 - 智慧北京] All versions of the libraries must be the same at this time.<br>[2014-05-24 15:54:24 - 智慧北京] Versions found are:<br>[2014-05-24 15:54:24 - 智慧北京] Path: D:\workspace\library\libs\android-support-v4.jar<br>[2014-05-24 15:54:24 - 智慧北京]     Length: 385685<br>[2014-05-24 15:54:24 - 智慧北京]     SHA-1: 48c94ae70fa65718b382098237806a5909bb096e<br>[2014-05-24 15:54:24 - 智慧北京] Path: D:\workspace\智慧北京\libs\android-support-v4.jar<br>[2014-05-24 15:54:24 - 智慧北京]     Length: 627582<br>[2014-05-24 15:54:24 - 智慧北京]     SHA-1: db0f122c99ef9f90dbab3fada6d191f2880cbb8e<br>[2014-05-24 15:54:24 - 智慧北京] Jar mismatch! Fix your dependencies</p>
<p>解决方案 ：把其中一个android-support-v4.jar复制到另外一个项目里面android-support-v4.jar</p>
<p>SHA家族[编辑]<br>安全散列算法（英语：Secure Hash Algorithm）是一种能计算出一个数字信息所对应到的，长度固定的字符串（又称信息摘要）的算法。<br>且若输入的信息不同，它们对应到不同字符串的机率很高；而SHA是FIPS所认证的五种安全散列算法。<br>这些算法之所以称作“安全”是基于以下两点（根据官方标准的描述）：“1)由信息摘要反推原输入信息，从计算理论上来说是很困难的。<br>2)想要找到两组不同的信息对应到相同的信息摘要，从计算理论上来说也是很困难的。任何对输入信息的变动，都有很高的机率导致其产生的信息摘要迥异。”</p>
<p>用途 ： 1 使用apk签名；<br>        2 妙传<br>        3 QQ令牌。动态密保。将军令。</p>
<p>05-24 08:16:47.566: E/AndroidRuntime(1049): FATAL EXCEPTION: main<br>05-24 08:16:47.566: E/AndroidRuntime(1049): java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{com.example.news/com.example.news.MainActivity}: java.lang.ClassNotFoundException: com.example.news.MainActivity<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:1983)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2084)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.app.ActivityThread.access$600(ActivityThread.java:130)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1195)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.os.Handler.dispatchMessage(Handler.java:99)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.os.Looper.loop(Looper.java:137)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.app.ActivityThread.main(ActivityThread.java:4745)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at java.lang.reflect.Method.invokeNative(Native Method)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at java.lang.reflect.Method.invoke(Method.java:511)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:786)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at dalvik.system.NativeStart.main(Native Method)<br>05-24 08:16:47.566: E/AndroidRuntime(1049): Caused by: java.lang.ClassNotFoundException: com.example.news.MainActivity<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:61)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at java.lang.ClassLoader.loadClass(ClassLoader.java:501)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at java.lang.ClassLoader.loadClass(ClassLoader.java:461)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.app.Instrumentation.newActivity(Instrumentation.java:1053)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:1974)<br>05-24 08:16:47.566: E/AndroidRuntime(1049):     … 11 more</p>
<p>原因 ：在引用library的时候，打包MainActivity的时候，没有把MainActivity打包进工程，所以找不到</p>
<p>解放方案 ： 1 重新编译一下项目；<br>              必须换一下SDK<br>              clean也是没有用。</p>
<p>05-24 08:32:04.227: E/AndroidRuntime(1212): FATAL EXCEPTION: main<br>05-24 08:32:04.227: E/AndroidRuntime(1212): java.lang.NullPointerException<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at com.jeremyfeinstein.slidingmenu.lib.CustomViewBehind.scrollBehindTo(CustomViewBehind.java:226)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at com.jeremyfeinstein.slidingmenu.lib.CustomViewAbove.scrollTo(CustomViewAbove.java:803)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at com.jeremyfeinstein.slidingmenu.lib.CustomViewAbove.onSizeChanged(CustomViewAbove.java:468)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.View.setFrame(View.java:13840)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.View.layout(View.java:13752)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.ViewGroup.layout(ViewGroup.java:4364)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.widget.RelativeLayout.onLayout(RelativeLayout.java:948)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.View.layout(View.java:13754)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.ViewGroup.layout(ViewGroup.java:4364)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.widget.FrameLayout.onLayout(FrameLayout.java:448)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.View.layout(View.java:13754)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.ViewGroup.layout(ViewGroup.java:4364)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.ViewRootImpl.performLayout(ViewRootImpl.java:1868)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:1689)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1000)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:4214)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.Choreographer$CallbackRecord.run(Choreographer.java:725)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.Choreographer.doCallbacks(Choreographer.java:555)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.Choreographer.doFrame(Choreographer.java:525)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:711)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.os.Handler.handleCallback(Handler.java:615)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.os.Handler.dispatchMessage(Handler.java:92)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.os.Looper.loop(Looper.java:137)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at android.app.ActivityThread.main(ActivityThread.java:4745)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at java.lang.reflect.Method.invokeNative(Native Method)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at java.lang.reflect.Method.invoke(Method.java:511)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:786)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)<br>05-24 08:32:04.227: E/AndroidRuntime(1212):     at dalvik.system.NativeStart.main(Native Method)</p>
<p>05-26 03:07:11.805: E/AndroidRuntime(277): FATAL EXCEPTION: main<br>05-26 03:07:11.805: E/AndroidRuntime(277): java.lang.StackOverflowError<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at java.lang.String.getChars(String.java:1003)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.text.TextUtils.getChars(TextUtils.java:63)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.text.TextUtils.indexOf(TextUtils.java:102)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.text.StaticLayout.generate(StaticLayout.java:131)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.text.StaticLayout.<init>(StaticLayout.java:97)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.text.StaticLayout.<init>(StaticLayout.java:54)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.text.StaticLayout.<init>(StaticLayout.java:45)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.TextView.makeNewLayout(TextView.java:4912)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.TextView.onMeasure(TextView.java:5174)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1012)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.measureVertical(LinearLayout.java:381)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.LinearLayout.onMeasure(LinearLayout.java:304)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.View.measure(View.java:8171)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:3132)<br>05-26 03:07:11.805: E/AndroidRuntime(277):     at android.widget.Line</init></init></init></p>
<p>tab页的展现形式?</p>
<p>1   fragment:</p>
<pre><code>a  我们需要使用fragment的话，我们只能用v4包里面的fragment，因为我们需要向下兼容。

b  当我们用V4包里面的fragment的时候，系统会自动添加一个节点。

c  fragment不允许嵌套fragment

d  这个谷歌是在4.2里面才解决的。假如我的SDK的版本不进行更新的话，是找不到这个方法的。
   android.support.v4.app的Fragment中找不到getChildFragmentManager()方法
</code></pre><p>2   viewPager:        </p>
<pre><code>a  因为使用起来方便。      
</code></pre><p>3    TabActivity:</p>
<pre><code>a ：TabActivity  过时，直接使用fragment 即可

b ：Activity是android里面的四大组件。是重量级的组件，fragment是android里面的片段，是特殊的view，他具备生命周期。
</code></pre><p>4    ViewGroup :</p>
<pre><code>a ：属于低级组件。比较麻烦。
</code></pre><p>activity view  和 window 之间关系</p>
<p>activity 只是一个控制器</p>
<p>android 性能布局优化</p>
<pre><code>1  当我们在画布局的时候，如果能实现相同的功能，优先考虑相对布局，然后在考虑别的布局，不要用绝对布局。

2 &lt;merge /&gt;标签做个介绍，是因为它在优化UI结构时起到很重要的作用
           单独将&lt;merge /&gt;标签做个介绍，是因为它在优化UI结构时起到很重要的作用。目的是通过删减多余或者额外的层级，
           从而优化整个Android Layout的结构。核心功能就是减少冗余的层次从而达到优化UI的目的！

3 ViewStub 是一个隐藏的，不占用内存空间的视图对象，它可以在运行时延迟加载布局资源文件。

4 &lt;include layout=&quot;@layout/activity_main&quot; /&gt; 把复杂的界面需要抽取出来
</code></pre><p>兄弟们的问题：</p>
<p>1 回调不懂。<br>2 多画图。<br>3 fragment不会用，生命周期不懂。<br>4 library引用不会。<br>5 LayoutInflater layoutInflater = LayoutInflater.from(context); 和<br>  LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);区别。<br>6 Merge是不是只能当做相对布局去用<br>7 讲课慢。</p>
<p>在android里面所有XML都是通过XmlPullParser方式进行的</p>
<p>setContentView(R.layout.activity_main);<br>setView(R.layout.activity_main);</p>
<p>目的是 ：不需要让viewpage默认加载下一页。</p>
<pre><code>int page = 1；
</code></pre><p>viewpager改变之前的：<br>05-26 08:14:51.108: I/System.out(718): instantiateItem  ::0<br>05-26 08:14:51.108: I/System.out(718): instantiateItem  ::1</p>
<p>05-26 08:15:48.947: I/System.out(718): instantiateItem  ::2</p>
<p>05-26 08:16:08.267: I/System.out(718): destroyItem  ::0<br>05-26 08:16:08.267: I/System.out(718): instantiateItem  ::3</p>
<hr>
<p>这个是自定义的懒加载的viewpager</p>
<p>05-26 08:20:51.647: I/System.out(787): instantiateItem  ::0</p>
<p>05-26 08:21:53.337: I/System.out(787): destroyItem  ::0<br>05-26 08:21:53.347: I/System.out(787): instantiateItem  ::1</p>
<p>05-26 08:22:18.907: I/System.out(787): destroyItem  ::1<br>05-26 08:22:18.918: I/System.out(787): instantiateItem  ::2</p>
<p>viewpager的源码</p>
<p>  final int pageLimit = mOffscreenPageLimit;<br>  final int startPos = Math.max(0, mCurItem - pageLimit); 3-1<br>  final int N = mAdapter.getCount();<br>  final int endPos = Math.min(N-1, mCurItem + pageLimit);</p>
<p>  if (DEBUG) Log.v(TAG, “populating: startPos=” + startPos + “ endPos=” + endPos);</p>
<p> 0<br> 0</p>
<p>1<br>1</p>
<p>2<br>4</p>
<p>0<br>1</p>
<p>0<br>2</p>
<p>1<br>3<br>目的，不让viewpager去进行滑动，静止滑动<br>解决方案：</p>
<p>fastjson和GSON的区别</p>
<p>1 fastjson 是阿里出的json解析工具<br>2 gson 是谷歌推荐的解析工具</p>
<p>1 fastjson在解析的时候，字段不能大写。<br>2 fastjson必须使用get和set方法</p>
<p>notifyDataSetInvalidated , notifyDataSetChanged 区别<br>notifyDataSetInvalidated()，会重绘控件（还原到初始状态）<br>notifyDataSetChanged()，重绘当前可见区域</p>
<p>正规开发项目的流程：listview展示<br>1 首先从本地数据去找。可以缓存到SD卡，也可以缓存到数据库，也可以缓存到sp<br>2 如果本地没有缓存数据的话，就需要进行联网，从服务器拉取数据。<br>3 在从服务器拉数据之前，先把本地数据展示一下，然后在从服务器拉数据进行替换。<br>4 如果从服务器把数据拉回来的时候，首先就需要缓存数据。<br>5 如果从服务器把数据拉回来之后，当在点击item的时候，需要缓存当条item的id。<br>6 下次在展示的时候，就需要先判断缓存里面是否有读取的id，isReadids。是boolean，用来判断，当前的商品<br>   或者新闻是否用户之前读取过。<br>7  如果当前用户读取了此条信息。我们就需要把当前的item的标题变色。eg：默认的话是黑色，读取之后，颜色变浅一点。   </p>
<p>封装adapter</p>
<p>目的：去掉冗余数据。</p>
<pre><code>@Override
public int getCount() {
    // TODO Auto-generated method stub
    return list.size();
}

@Override
public Object getItem(int position) {
    // TODO Auto-generated method stub
    return list.get(position);
}

@Override
public long getItemId(int position) {
    // TODO Auto-generated method stub
    return position;
}
</code></pre><p>  我们在实际开发过程中，只需要关注getview（）；<br>public View getView(int position, View convertView, ViewGroup parent) {</p>
<p>}</p>
<p>android事件的分发机制。</p>
<p>1 button 把这个button放到item上面就会去抢焦点。enable 设置为false。<br>  imageview 把这个imaegview放到item上面就不会抢焦点。</p>
<p>button Touch方法返回false打印出来的值  </p>
<p>05-27 08:29:32.215: I/System.out(830): Button –onTouch ==0</p>
<p>05-27 08:29:32.308: I/System.out(830): Button –onTouch ==1<br>05-27 08:29:32.318: I/System.out(830): Button –OnClickListener</p>
<p>button Touch方法返回true打印出来的值    </p>
<p>05-27 08:35:46.579: I/System.out(881): Button –onTouch ==0<br>05-27 08:35:46.719: I/System.out(881): Button –onTouch ==1</p>
<p>public boolean dispatchTouchEvent(MotionEvent event) {<br>        if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) {<br>            return true;<br>        }<br>        return onTouchEvent(event);<br>    }  </p>
<p>  public boolean onTouchEvent(MotionEvent event) {</p>
<pre><code> 。。。。。。。。。。。。。。。。。。。

 if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {


          switch (event.getAction()) {
            case MotionEvent.ACTION_UP:

             public boolean performClick() {
                 sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);

                 if (mOnClickListener != null) {
                     playSoundEffect(SoundEffectConstants.CLICK);
                     mOnClickListener.onClick(this);
                     return true;
                  }

    return false;
}



            }




}


 。。。。。。。。。。。。。。。。。。。
</code></pre><p>  }</p>
<p> ImageView；Touch事件设置为false</p>
<p>05-27 08:47:46.189: I/System.out(941): ImageView –onTouch ==0</p>
<p>当Touch事件设置为false的时候，不会去进行分发。因为已经消费掉了。</p>
<p> ImageView；Touch事件设置为true</p>
<p>05-27 08:51:31.852: I/System.out(992): ImageView –onTouch ==0<br>05-27 08:51:32.056: I/System.out(992): ImageView –onTouch ==1</p>
<p>在android里面所有的控件view，并不能设置宽高，也就是说所有的控件，没有宽高。<br>谷歌压根就没有提供设置方法。</p>
<p>设置bitmap的色彩模式：</p>
<p>位图：</p>
<p>图片的内存 = 图片的长 <em>  图片的宽 </em> 单位图片像素字节数</p>
<p>Config.RGB_565的色彩模式</p>
<p>RGB R占5位 G占6位 B占5</p>
<p>bitmapUtils.configDefaultBitmapConfig(Config.RGB_565);</p>
<p>bitmapUtils.configDefaultBitmapConfig(Config.ALPHA_8);</p>
<p>bitmapUtils.configDefaultBitmapConfig(Config.ARGB_4444);</p>
<p>bitmapUtils.configDefaultBitmapConfig(Config.ARGB_8888);</p>
<p>[2014-05-30 10:16:36 - Dex Loader] Unable to execute dex: java.nio.BufferOverflowException. Check the Eclipse log for stack trace.<br>[2014-05-30 10:16:36 - LazyList] Conversion to Dalvik format failed: Unable to execute dex: java.nio.BufferOverflowException. Check the Eclipse log for stack trace.</p>
<p>1 首先得知道系统给我们的应用分配了多少内存？32 16</p>
<p>Runtime.getRuntime().maxMemory()；<br>2 32/4 = 8 这个8MB内存用来作为参照物。<br>3 在每次做内存的时候，都检查一下内存。跟8对比一下，如果超过了8MB的话，我们就直接移除内存里面的缓存。如果没有超过8MB的话，我们是不是就可以放心大胆的缓存图片了。</p>
<p>4 在加载图片的时候，先必须从内存当中去查找是否有缓存图片。如果有就直接返回。通过imageview去加载图片。如果没有返回图片。若没有的话则开启新线程加载图片。<br>  内存缓存就是一级缓存。</p>
<p>  文件缓存，也可以叫做SD卡缓存。二级缓存</p>
<p>  网络加载图片，也可以叫做三级缓存。</p>
<p>1 消息推送：</p>
<p>  1 必须有资金的支持。够买大量的服务器。1000W 一台服务器支持10个链接。  需要100台服务器。200台服务器,一台服务器是5W的.<br>  2 技术难度特别大.公网IP,由于我们国家ipv4的ip地址不够.运营商,给你分配的内网IP,链接到公网的网关.192.168.1.100 ,1,2,3,4</p>
<p>  3 轮寻的方式.(耗电量特别大.)<br>  4 短信实现.(短信的收费)<br>  5 长链接.</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/24/java-instance/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Java实现单例模式的正确姿势
        
      </div>
    </a>
  
  
    <a href="/2016/03/21/android-toolbar-theme-bug/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Toolbar主题Theme.AppCompat.Light.DarkActionBar的使用</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="note" data-title="技术笔记集合" data-url="http://yoursite.com/2016/03/23/note/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"yuweiguo"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 于卫国
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: falsee,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>